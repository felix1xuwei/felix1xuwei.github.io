<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Felix1XuWei&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Felix1XuWei&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Felix1XuWei&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Felix1XuWei's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Felix1XuWei's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/27/protobuf-源码中值得学习的地方/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/27/protobuf-源码中值得学习的地方/" itemprop="url">Protobuf-源码中值得学习的地方</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-27T15:08:32+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用宏来提高代码可读性（代码的美感）"><a href="#使用宏来提高代码可读性（代码的美感）" class="headerlink" title="使用宏来提高代码可读性（代码的美感）"></a>使用宏来提高代码可读性（代码的美感）</h2><h3 id="例1-宏CHARACTER-CLASS"><a href="#例1-宏CHARACTER-CLASS" class="headerlink" title="例1.宏CHARACTER_CLASS"></a>例1.宏CHARACTER_CLASS</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>tokenizer.cc</code>文件中，需要判断某个character是属于哪种类型的字符，通过宏<code>CHARACTER_CLASS</code>来定义字符类型，并且定义static类型的<code>InClass()</code>接口来判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARACTER_CLASS(NAME, EXPRESSION)      \</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NAME</span> &#123;</span>                                 \</span><br><span class="line">   <span class="keyword">public</span>:                                     \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">InClass</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;       \</span><br><span class="line">      <span class="keyword">return</span> EXPRESSION;                       \</span><br><span class="line">    &#125;                                          \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">CHARACTER_CLASS(Whitespace, c == <span class="string">' '</span> || c == <span class="string">'\n'</span> || c == <span class="string">'\t'</span> ||</span><br><span class="line">                            c == <span class="string">'\r'</span> || c == <span class="string">'\v'</span> || c == <span class="string">'\f'</span>);</span><br><span class="line"></span><br><span class="line">CHARACTER_CLASS(Unprintable, c &lt; <span class="string">' '</span> &amp;&amp; c &gt; <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">CHARACTER_CLASS(Digit, <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">CHARACTER_CLASS(OctalDigit, <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'7'</span>);</span><br><span class="line">CHARACTER_CLASS(HexDigit, (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) ||</span><br><span class="line">                          (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span><br><span class="line">                          (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>));</span><br><span class="line"></span><br><span class="line">CHARACTER_CLASS(Letter, (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>) ||</span><br><span class="line">                        (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>) ||</span><br><span class="line">                        (c == <span class="string">'_'</span>));</span><br><span class="line"></span><br><span class="line">CHARACTER_CLASS(Alphanumeric, (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>) ||</span><br><span class="line">                              (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>) ||</span><br><span class="line">                              (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) ||</span><br><span class="line">                              (c == <span class="string">'_'</span>));</span><br><span class="line"></span><br><span class="line">CHARACTER_CLASS(Escape, c == <span class="string">'a'</span> || c == <span class="string">'b'</span> || c == <span class="string">'f'</span> || c == <span class="string">'n'</span> ||</span><br><span class="line">                        c == <span class="string">'r'</span> || c == <span class="string">'t'</span> || c == <span class="string">'v'</span> || c == <span class="string">'\\'</span> ||</span><br><span class="line">                        c == <span class="string">'?'</span> || c == <span class="string">'\''</span> || c == <span class="string">'\"'</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CHARACTER_CLASS</span></span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用时可以直接使用InClass():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharacterClass&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Tokenizer::TryConsumeOne() &#123;</span><br><span class="line">  <span class="keyword">if</span> (CharacterClass::InClass(current_char_)) &#123;</span><br><span class="line">    NextChar();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="例2-宏-PROTOBUF-DEFINE-ACCESSOR"><a href="#例2-宏-PROTOBUF-DEFINE-ACCESSOR" class="headerlink" title="例2.宏 PROTOBUF_DEFINE_ACCESSOR"></a>例2.宏 PROTOBUF_DEFINE_ACCESSOR</h3><p><code>FieldDescriptor</code>类，因为可能类型是多样的，在实现对外暴露default数据的函数时，为了提高代码可读性，使用了如下宏的方式(文件descriptor.cc中)：</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These macros makes this repetitive code more readable.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_DEFINE_ACCESSOR(CLASS, FIELD, TYPE) \</span></span><br><span class="line">  <span class="keyword">inline</span> TYPE CLASS::FIELD() <span class="keyword">const</span> &#123; <span class="keyword">return</span> FIELD##_; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_int32 , int32 )</span><br><span class="line">PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, has_default_value, <span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure>
<h3 id="例3-宏BUILD-ARRAY"><a href="#例3-宏BUILD-ARRAY" class="headerlink" title="例3.宏BUILD_ARRAY"></a>例3.宏BUILD_ARRAY</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>BUILD_ARRAY宏定义如下，这里的INPUT是proto；OUTPUT是proto对应的descriptor；NAME是需要完成创建的成员；METHOD是创建descriptor成员时需要调用的函数；PARENT是发生嵌套时的上一级。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// A common pattern:  We want to convert a repeated field in the descriptor</span></span><br><span class="line"><span class="comment">// to an array of values, calling some method to build each value.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILD_ARRAY(INPUT, OUTPUT, NAME, METHOD, PARENT)             \</span></span><br><span class="line">  OUTPUT-&gt;NAME##_count_ = INPUT.NAME##_size();                       \</span><br><span class="line">  AllocateArray(INPUT.NAME##_size(), &amp;OUTPUT-&gt;NAME##s_);             \</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INPUT.NAME##_size(); i++) &#123;                    \</span><br><span class="line">    METHOD(INPUT.NAME(i), PARENT, OUTPUT-&gt;NAME##s_ + i);             \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>DescriptorBuilder::BuildFile()中，利用FileDescriptorProto&amp; proto来构建对应的descriptor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert children.</span></span><br><span class="line">BUILD_ARRAY(proto, result, message_type, BuildMessage  , <span class="literal">NULL</span>);</span><br><span class="line">BUILD_ARRAY(proto, result, enum_type   , BuildEnum     , <span class="literal">NULL</span>);</span><br><span class="line">BUILD_ARRAY(proto, result, service     , BuildService  , <span class="literal">NULL</span>);</span><br><span class="line">BUILD_ARRAY(proto, result, extension   , BuildExtension, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>各个Descriptor类中，使用count + 连续内存来保存成员，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LIBPROTOBUF_EXPORT</span> <span class="title">FileDescriptor</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其它代码</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> message_type_count_;</span><br><span class="line">	Descriptor* message_types_;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//省略其它代码</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源分配-处理的lazy机制"><a href="#资源分配-处理的lazy机制" class="headerlink" title="资源分配/处理的lazy机制"></a>资源分配/处理的lazy机制</h2><h3 id="例1-类DescriptorPool数据分层设计"><a href="#例1-类DescriptorPool数据分层设计" class="headerlink" title="例1.类DescriptorPool数据分层设计"></a>例1.类DescriptorPool数据分层设计</h3><p>DescriptorPool的数据管理分为了多层（忽略了仅在protobuf内部使用 &amp;&amp; 不推荐使用的underlay一层）：  </p>
<ul>
<li>最顶层：<code>DescriptorPool::Tables tables_</code>，保存<code>name-&gt;descriptor</code>;</li>
<li>最底层：<code>DescriptorDatabase* fallback_database_</code>,保存<code>name-&gt;file_descriptor_proto</code>(而不是直接的<code>file_descriptor</code>)</li>
</ul>
<p>查找时，如果第一层<code>tables_</code>没找到，最终会到<code>fallback_database_</code>中找对应proto，并且调用临时构造的<code>DescriptorBuilder::Build*()</code>系列接口把生成的descriptor添加到<code>tables_</code>中，然后再从<code>tables_</code>中找。</p>
<p>这样数据分层设计的目的是：  </p>
<ol>
<li>用于定制地(on-demand)从某种”大”的database加载产生DescriptorPool。因为database太大，逐个调用<code>DescriptorPool::BuildFile()</code> 来处理原database中的每一个proto文件是低效的。<br>为了提升效率，使用DescriptorPool来封装DescriptorDatabase，并且只建立正真需要的descriptor。</li>
<li>针对编译依赖的每个proto文件，并不是在进程启动时，直接构建出proto中所包含的所有descriptor，而是hang on，直到某个descriptor真的被需要：<br>(1)用户调用例如descriptor(), GetDescriptor(), GetReflection()的方法，需要返回descriptor；<br>(2)用户从<code>DescriptorPool::generated_pool()</code>中查找descriptor；</li>
</ol>
<p>可以看到descriptor的构建是hang-on的，只有需要使用某个descriptor时，才构建。适合依赖了很多的proto文件，但仅仅使用其中的少数proto的场景。</p>
<h3 id="例2-类GeneratedMessageFactory映射关系加载"><a href="#例2-类GeneratedMessageFactory映射关系加载" class="headerlink" title="例2.类GeneratedMessageFactory映射关系加载"></a>例2.类GeneratedMessageFactory映射关系加载</h3><p><code>GeneratedMessageFactory</code>类，管理的从<code>Descriptor* -&gt; Message*</code>映射关系，并不是一开始就注册好的。仅仅在需要从descriptr查找message时(调用<code>GeneratedMessageFactory::GetPrototype()</code>)，才会：  </p>
<ol>
<li>通过file_name找到注册函数；</li>
<li>调用注册函数，完成<code>Descriptor* -&gt; Message*</code>映射关系的注册；</li>
<li>从<code>hash_map&lt;const Descriptor*, const Message*&gt; type_map_</code>查找到对应<code>Message*</code>返回；</li>
</ol>
<h2 id="资源管理-内存复用"><a href="#资源管理-内存复用" class="headerlink" title="资源管理/内存复用"></a>资源管理/内存复用</h2><h3 id="类RepeatedPtrFieldBase"><a href="#类RepeatedPtrFieldBase" class="headerlink" title="类RepeatedPtrFieldBase"></a>类RepeatedPtrFieldBase</h3><p>RepeatedPtrFields的父类（不是模板类，提供了多个模板函数），本身保存/管理的数据类型为<code>void*</code>（message对象的实际地址，也是通过连续内存array来保存）。</p>
<p>因为array中保存的是同一个descriptor对应的message，只是各个message中所包含的数据不一样，为了<code>节省下message对象分配/释放的成本</code>，所以message可以被clear(clear操作会将primitive类型的field设置为0，其余类型field调用自身的clear()接口处理，类似<code>std::string::clear()</code>,只清理数据并不回收内存)。<br>然后保留原有的内存地址在array中。下次需要从array中分配message时，优先使用这一批被clear的message（实现在<code>RepeatedPtrFieldBase::AddFromCleared()</code> ，参考<code>GeneratedMessageReflection::AddMessage()</code>中的调用方式）。  </p>
<p>为了管理cleared状态的message指针，引入了多个游标来标记数据：</p>
<ul>
<li><code>current_size_</code>: 当前待处理的message地址；</li>
<li><code>allocated_size_</code>:已经分配message的数据，<code>current_size_ &lt;= allocated_size_</code>，从<code>current_size_</code>到<code>allocated_size_</code>之间的message就是被cleared的；</li>
<li><code>total_size_</code>:<code>elements_[]</code>的长度，但从<code>allocated_size_</code>到<code>total_size_</code>之间的<code>void*</code>是无效的，并没有指向任何message；</li>
</ul>
<p>对应内存分布如下图所示：</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_repeated_memory.png" alt="avatar"></p>
<h2 id="封装多种类型，统一对外的服务"><a href="#封装多种类型，统一对外的服务" class="headerlink" title="封装多种类型，统一对外的服务"></a>封装多种类型，统一对外的服务</h2><p>针对数据/行为简单的类型，使用轻量级的方案（<code>struct/enum/union/switch-case</code>），来实现类型的封装，而不是采用继承方式来实现。</p>
<p><strong>Symbol可能有多种类型，<code>enum Type</code>表示具体类型，<code>union</code>让多种类型都复用同一个内存地址：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Symbol</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    NULL_SYMBOL, MESSAGE, FIELD, ENUM, ENUM_VALUE, SERVICE, METHOD, PACKAGE</span><br><span class="line">  &#125;;</span><br><span class="line">  Type type;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Descriptor* descriptor;</span><br><span class="line">    <span class="keyword">const</span> FieldDescriptor* field_descriptor;</span><br><span class="line">    <span class="keyword">const</span> EnumDescriptor* enum_descriptor;</span><br><span class="line">    <span class="keyword">const</span> EnumValueDescriptor* enum_value_descriptor;</span><br><span class="line">    <span class="keyword">const</span> ServiceDescriptor* service_descriptor;</span><br><span class="line">    <span class="keyword">const</span> MethodDescriptor* method_descriptor;</span><br><span class="line">    <span class="keyword">const</span> FileDescriptor* package_file_descriptor;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">inline Symbol() : type(NULL_SYMBOL) &#123; descriptor = NULL; &#125;</span><br><span class="line">…… <span class="comment">//省略部分</span></span><br></pre></td></tr></table></figure>
<p><strong>宏<code>CONSTRUCTOR</code>帮助提高代码可读性，来实现不同类型Symbol的构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTRUCTOR(TYPE, TYPE_CONSTANT, FIELD)  \</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">Symbol</span><span class="params">(<span class="keyword">const</span> TYPE* value)</span> </span>&#123;    \</span><br><span class="line">    type = TYPE_CONSTANT;                        \</span><br><span class="line">    <span class="keyword">this</span>-&gt;FIELD = value;                         \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>宏<code>CONSTRUCTOR</code>的使用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  CONSTRUCTOR(Descriptor         , MESSAGE   , descriptor             )</span><br><span class="line">  CONSTRUCTOR(FieldDescriptor    , FIELD     , field_descriptor       )</span><br><span class="line">  CONSTRUCTOR(EnumDescriptor     , ENUM      , enum_descriptor        )</span><br><span class="line">  CONSTRUCTOR(EnumValueDescriptor, ENUM_VALUE, enum_value_descriptor  )</span><br><span class="line">  CONSTRUCTOR(ServiceDescriptor  , SERVICE   , service_descriptor     )</span><br><span class="line">  CONSTRUCTOR(MethodDescriptor   , METHOD    , method_descriptor      )</span><br><span class="line">  CONSTRUCTOR(FileDescriptor     , PACKAGE   , package_file_descriptor)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CONSTRUCTOR</span></span><br></pre></td></tr></table></figure>
<p><strong>具体应用时，根据<code>type</code>来区分处理：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">const</span> FileDescriptor* <span class="title">GetFile</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> NULL_SYMBOL: <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">case</span> MESSAGE    : <span class="keyword">return</span> descriptor           -&gt;file();</span><br><span class="line">      <span class="keyword">case</span> FIELD      : <span class="keyword">return</span> field_descriptor     -&gt;file();</span><br><span class="line">      <span class="keyword">case</span> ENUM       : <span class="keyword">return</span> enum_descriptor      -&gt;file();</span><br><span class="line">      <span class="keyword">case</span> ENUM_VALUE : <span class="keyword">return</span> enum_value_descriptor-&gt;type()-&gt;file();</span><br><span class="line">      <span class="keyword">case</span> SERVICE    : <span class="keyword">return</span> service_descriptor   -&gt;file();</span><br><span class="line">      <span class="keyword">case</span> METHOD     : <span class="keyword">return</span> method_descriptor    -&gt;service()-&gt;file();</span><br><span class="line">      <span class="keyword">case</span> PACKAGE    : <span class="keyword">return</span> package_file_descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不同的类作为模版参数时，提供类独有的类型"><a href="#不同的类作为模版参数时，提供类独有的类型" class="headerlink" title="不同的类作为模版参数时，提供类独有的类型"></a>不同的类作为模版参数时，提供类独有的类型</h2><p>类<code>GenericTypeHandler</code>和类<code>StringTypeHandler</code> 需要作为模版类型参数（<code>typehandler</code>），在子类<code>RepeatedPtrField</code>在调用父类<code>RepeatedPtrFieldBase</code>的模板函数时，通过模板参数直接传入父类<code>RepeatedPtrFieldBase</code>，这里需要根据不同的<code>typehandler</code>，返回对应不同的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TypeHandler&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> TypeHandler::Type&amp;</span><br><span class="line">RepeatedPtrFieldBase::Get(<span class="keyword">int</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">  GOOGLE_DCHECK_LT(index, size());</span><br><span class="line">  <span class="keyword">return</span> *cast&lt;TypeHandler&gt;(elements_[index]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>所以有如下方式，在不同模版参数类型中通过<code>typedef</code>方式来实现类型名称的统一，因为对于模版来说，关键点就是有统一的名称。</p>
<p><strong>GenericTypeHandler</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GenericType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTypeHandler</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> GenericType Type;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> GenericType* <span class="title">New</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> GenericType; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(GenericType* value)</span> </span>&#123; <span class="keyword">delete</span> value; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(GenericType* value)</span> </span>&#123; value-&gt;Clear(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">const</span> GenericType&amp; from, GenericType* to)</span> </span>&#123;</span><br><span class="line">    to-&gt;MergeFrom(from);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SpaceUsed</span><span class="params">(<span class="keyword">const</span> GenericType&amp; value)</span> </span>&#123; <span class="keyword">return</span> value.SpaceUsed(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>StringTypeHandler</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HACK:  If a class is declared as DLL-exported in MSVC, it insists on</span></span><br><span class="line"><span class="comment">//   generating copies of all its methods -- even inline ones -- to include</span></span><br><span class="line"><span class="comment">//   in the DLL.  But SpaceUsed() calls StringSpaceUsedExcludingSelf() which</span></span><br><span class="line"><span class="comment">//   isn't in the lite library, therefore the lite library cannot link if</span></span><br><span class="line"><span class="comment">//   StringTypeHandler is exported.  So, we factor out StringTypeHandlerBase,</span></span><br><span class="line"><span class="comment">//   export that, then make StringTypeHandler be a subclass which is NOT</span></span><br><span class="line"><span class="comment">//   exported.</span></span><br><span class="line"><span class="comment">// TODO(kenton):  There has to be a better way.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LIBPROTOBUF_EXPORT</span> <span class="title">StringTypeHandlerBase</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">string</span> Type;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">string</span>* <span class="title">New</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="built_in">string</span>* value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(<span class="built_in">string</span>* value)</span> </span>&#123; value-&gt;clear(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; from, <span class="built_in">string</span>* to)</span> </span>&#123; *to = from; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LIBPROTOBUF_EXPORT</span> <span class="title">StringTypeHandler</span> :</span> <span class="keyword">public</span> StringTypeHandlerBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SpaceUsed</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; value)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(value) + StringSpaceUsedExcludingSelf(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应类的关系图：</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_repeated_class_diagram.png" alt="avatar"></p>
<h2 id="低配版release来节省资源"><a href="#低配版release来节省资源" class="headerlink" title="低配版release来节省资源"></a>低配版release来节省资源</h2><p>在proto文件中增加配置，产出不支持reflection/descriptor的MessageLite子类，而不是Message子类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option optimize_for = LITE_RUNTIME</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/27/protobuf-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/27/protobuf-plugin/" itemprop="url">Protobuf-Plugin机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-27T13:36:41+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="plugin机制"><a href="#plugin机制" class="headerlink" title="plugin机制"></a>plugin机制</h2><p>protobuf是一个支持plugin机制的序列化框架，除了protobuf自带的几种语言的CodeGenerator，用户可以按需实现自己的插件，来实现语言的拓展（比如protoc-gen-lua）或者功能的拓展(厂子内部的mcpack2pb插件)。  </p>
<p>因为protoc插件需要实现跨平台、跨语言，所以采用的方式是父子进程的工作方式，父子进程通过pipe（父子进程共享fd）方式通信，父子进程通信数据的格式定义在compiler/plugin.proto。</p>
<ol>
<li>父进程（protoc进程）中负责读取proto文件，转化为CodeGeneratorRequest格式，启动子进程，以及后续持久化子进程返回内容；</li>
<li>子进程（自定义插件进程）完成中子进程中启动自定义的CodeGeneratorResponse格式，按照自己需要完成处理，返回给父进程（protoc进程）；</li>
</ol>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_plugin_process.png" alt="avatar"></p>
<h4 id="父子进程共享fd工作机制说明："><a href="#父子进程共享fd工作机制说明：" class="headerlink" title="父子进程共享fd工作机制说明："></a>父子进程共享fd工作机制说明：</h4><p>利用父子进程共享fd机制，建立pipe（单工模式）。</p>
<ol>
<li>子进程一侧，做重定向，将<code>stdin_pipe[0]</code>重定向到<code>STDIN_FILENO</code>，<code>stdout_pipe[1]</code>重定向到<code>STDOUT_FILENO</code>，这样plugin处理过程中，无需记录下输入/输出fd；</li>
<li>父进程一侧，从<code>stdin_pipe[1]</code>写入数据，然后从<code>stdout_pipe[0]</code>读数据；</li>
</ol>
<h4 id="父子进程通信接口定义说明："><a href="#父子进程通信接口定义说明：" class="headerlink" title="父子进程通信接口定义说明："></a>父子进程通信接口定义说明：</h4><p>定义格式在compiler/plugin.proto中，也是采用proto方式来完成自定义的。</p>
<p>CodeGeneratorRequest按照文件粒度FileDescriptorProto来提供：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		message CodeGeneratorRequest &#123;</span><br><span class="line">		  repeated <span class="built_in">string</span> file_to_generate = <span class="number">1</span>;</span><br><span class="line">		  optional <span class="built_in">string</span> parameter = <span class="number">2</span>;</span><br><span class="line">		  repeated FileDescriptorProto proto_file = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CodeGeneratorResponse 返回结果中，返回文件内容是直接用string表达，protoc主进程直接负责后续持久化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message CodeGeneratorResponse &#123;</span><br><span class="line">  optional <span class="built_in">string</span> error = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Represents a single generated file.</span></span><br><span class="line">  message File &#123;</span><br><span class="line">    optional <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">    optional <span class="built_in">string</span> insertion_point = <span class="number">2</span>;</span><br><span class="line">    optional <span class="built_in">string</span> content = <span class="number">15</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated File file = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="plugin实现方式："><a href="#plugin实现方式：" class="headerlink" title="plugin实现方式："></a>plugin实现方式：</h4><p>自定义 CodeGenerator类的子类MyCodeGenerator，在plugin进程的main函数中直接调用<code>google::protobuf::compiler::PluginMain()</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	     MyCodeGenerator generator;</span><br><span class="line">	     <span class="keyword">return</span> google::protobuf::compiler::PluginMain(argc, argv, &amp;generator);</span><br><span class="line">	   &#125;</span><br></pre></td></tr></table></figure>
<p><code>google::protobuf::compiler::PluginMain()</code>的功能：</p>
<ol>
<li>从STDIN_FILENO读取protoc主进程的输入数据，并且反序列化到CodeGeneratorRequest request；</li>
<li>从FileDescriptorProto产出FileDescriptor</li>
<li>调用MyCodeGenerator::Generate()</li>
<li>输出CodeGeneratorResponse response序列化之后的结果到STDOUT_FILENO，提供给protoc主进程</li>
</ol>
<h4 id="Subprocess类"><a href="#Subprocess类" class="headerlink" title="Subprocess类"></a>Subprocess类</h4><ol>
<li>负责建立父子进程之间的pipe，启动子进程</li>
<li>完成父子进程之间通信的数据格式转换</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/26/protobuf-compiler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/26/protobuf-compiler/" itemprop="url">Protobuf-Compiler相关类&代码生成流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-26T15:08:17+08:00">
                2018-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="代码生成流程："><a href="#代码生成流程：" class="headerlink" title="代码生成流程："></a>代码生成流程：</h2><p>核心流程如下图所示：</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_compiler_flow.png" alt="avatar"></p>
<h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><h3 id="类CommandLineInterface"><a href="#类CommandLineInterface" class="headerlink" title="类CommandLineInterface"></a>类CommandLineInterface</h3><ol>
<li><code>generators_</code>: <code>map&lt;string, GeneratorInfo&gt;</code>，提供从”–cpp_out” -&gt; CppGenerator的映射，从protoc参数中获取需要的generator的名称；</li>
<li><code>plugins_</code>：<code>map&lt;string, string&gt;</code> ，plugin提供非protobuf已有的CodeGenerator服务，plugin采用进程方式提供服务。<code>plugins_</code>记录的是：plugin名称 -&gt; plugin可执行程序在磁盘上的path</li>
<li><code>plugin_prefix_</code>： 设置为”protoc-“</li>
</ol>
<h3 id="类SourceTree"><a href="#类SourceTree" class="headerlink" title="类SourceTree"></a>类SourceTree</h3><p>接口类，表示.proto文件的目录树。</p>
<h3 id="类DiskSourceTree"><a href="#类DiskSourceTree" class="headerlink" title="类DiskSourceTree"></a>类DiskSourceTree</h3><p>类SourceTree的子类，用于加载磁盘上的多个文件，并且提供 从 物理磁盘路径/文件 -&gt;SourceTree上的节点的map关系.还可以设置”” -&gt; SourceTree上的root节点。如果多个路径设置对应了同一个文件，那么搜索时会按照设置的顺序来处理。</p>
<h3 id="类Importer"><a href="#类Importer" class="headerlink" title="类Importer"></a>类Importer</h3><p>根据.proto文件的name，返回对应的FileDescriptor。实际是通过DescriptorPool提供的服务。</p>
<h3 id="类io-Tokenizer"><a href="#类io-Tokenizer" class="headerlink" title="类io::Tokenizer"></a>类io::Tokenizer</h3><p>词法分析器，1个Tokenizer对象处理一个ZeroCopyInputStream，将raw text的stream转化为能够被parser解析的stream（token序列）。外部使用者仅需循环调用Tokenizer::Next()和Tokenizer::current()，就可以按照顺序获得对应的token，就像一个token化的stream一样。</p>
<h4 id="token的定义如下："><a href="#token的定义如下：" class="headerlink" title="token的定义如下："></a>token的定义如下：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenType type;</span><br><span class="line">  <span class="built_in">string</span> text;       <span class="comment">// The exact text of the token as it appeared in</span></span><br><span class="line">                     <span class="comment">// the input.  e.g. tokens of TYPE_STRING will still</span></span><br><span class="line">                     <span class="comment">// be escaped and in quotes.</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// "line" and "column" specify the position of the first character of</span></span><br><span class="line">  <span class="comment">// the token within the input stream.  They are zero-based.</span></span><br><span class="line">  <span class="keyword">int</span> line;</span><br><span class="line">  <span class="keyword">int</span> column;</span><br><span class="line">  <span class="keyword">int</span> end_column;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="token类型定义："><a href="#token类型定义：" class="headerlink" title="token类型定义："></a>token类型定义：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TokenType &#123;</span><br><span class="line">  TYPE_START,       <span class="comment">// Next() has not yet been called.</span></span><br><span class="line">  TYPE_END,         <span class="comment">// End of input reached.  "text" is empty.</span></span><br><span class="line">	</span><br><span class="line">  TYPE_IDENTIFIER,  <span class="comment">// A sequence of letters, digits, and underscores, not</span></span><br><span class="line">                    <span class="comment">// starting with a digit.  It is an error for a number</span></span><br><span class="line">                    <span class="comment">// to be followed by an identifier with no space in</span></span><br><span class="line">                    <span class="comment">// between.</span></span><br><span class="line">  TYPE_INTEGER,     <span class="comment">// A sequence of digits representing an integer.  Normally</span></span><br><span class="line">                    <span class="comment">// the digits are decimal, but a prefix of "0x" indicates</span></span><br><span class="line">                    <span class="comment">// a hex number and a leading zero indicates octal, just</span></span><br><span class="line">                    <span class="comment">// like with C numeric literals.  A leading negative sign</span></span><br><span class="line">                    <span class="comment">// is NOT included in the token; it's up to the parser to</span></span><br><span class="line">                    <span class="comment">// interpret the unary minus operator on its own.</span></span><br><span class="line">  TYPE_FLOAT,       <span class="comment">// A floating point literal, with a fractional part and/or</span></span><br><span class="line">                    <span class="comment">// an exponent.  Always in decimal.  Again, never</span></span><br><span class="line">                    <span class="comment">// negative.</span></span><br><span class="line">  TYPE_STRING,      <span class="comment">// A quoted sequence of escaped characters.  Either single</span></span><br><span class="line">                    <span class="comment">// or double quotes can be used, but they must match.</span></span><br><span class="line">                    <span class="comment">// A string literal cannot cross a line break.</span></span><br><span class="line">  TYPE_SYMBOL,      <span class="comment">// Any other printable character, like '!' or '+'.</span></span><br><span class="line">                    <span class="comment">// Symbols are always a single character, so "!+$%" is</span></span><br><span class="line">                    <span class="comment">// four tokens.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>处理性能是O(n)，处理过程：</p>
<ol>
<li>使用buffer_从ZeroCopyInputStream中获取对应raw data，current_表示当前的token对象，previous_表示上一个token对象；</li>
<li>将character分为8种类型(通过宏CHARACTER_CLASS定义)：Whitespace/Unprintable/Digit/OctalDigit/HexDigit/Letter/Alphanumeric/Escape</li>
<li><p>使用buffer_pos_指向当前处理character的位置，并且逐个character向后移动处理，根据character的类型（有时需要结合previous_.type）判断current_ token的类型和边界，核心处理过程在Tokenizer::Next() 中：</p>
<pre><code>(1)先判断和处理Whitespace字符；
(2)再判断和处理COMMENT字符串
(3)判断和处理Unprintable字符；
(4)判断和处理其余类型字符，生成有效的token；
</code></pre></li>
</ol>
<h3 id="类Parser"><a href="#类Parser" class="headerlink" title="类Parser"></a>类Parser</h3><p>语法分析器，将tokenizer对象（proto文件对应的token化的stream）转化为FileDescriptorProto.<br><code>递归下降语法分析器 （recursive-descent-parser）</code>  <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Recursive_descent_parser</a></p>
<h4 id="核心数据成员："><a href="#核心数据成员：" class="headerlink" title="核心数据成员："></a>核心数据成员：</h4><pre><code>io::Tokenizer* input_;                                // 提供需要parse的token stream
SourceCodeInfo* source_code_info_;    // 记录整个proto文件中所有token的location信息（path和span），用于开发工具使用，并不影响产出的FileDescriptorProto内容
</code></pre><h4 id="处理过程："><a href="#处理过程：" class="headerlink" title="处理过程："></a>处理过程：</h4><p><code>Parser::Parse()</code>中循环扫描input的tokenizer，来调用<code>Parser::ParseTopLevelStatement()</code>来处理的，注意在整个处理过程中root_location的传递，使得当前层级继承了上一个层级的location信息。整个过程按照proto文件的层级结构进行，是recursive的。</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_compiler_parser_1.png" alt="avatar"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">bool</span> Parser::Parse(io::Tokenizer* input, FileDescriptorProto* file) &#123;</span><br><span class="line">	</span><br><span class="line">		…… <span class="comment">//省略</span></span><br><span class="line">		<span class="function">LocationRecorder <span class="title">root_location</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">		</span><br><span class="line">		 …… <span class="comment">//省略</span></span><br><span class="line">		</span><br><span class="line">		    <span class="comment">// Repeatedly parse statements until we reach the end of the file.</span></span><br><span class="line">		    <span class="keyword">while</span> (!AtEnd()) &#123;</span><br><span class="line">		      <span class="keyword">if</span> (!ParseTopLevelStatement(file, root_location)) &#123;</span><br><span class="line">		           …… <span class="comment">//省略</span></span><br><span class="line">		</span><br><span class="line">		             input_-&gt;Next();</span><br><span class="line">		        &#125;</span><br><span class="line">		      &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		…… <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>location的信息传递，是通过如下方式(path上增加了FileDescriptorProto::kMessageTypeFieldNumber，以及当前状态下file层级中message的数量，也就是当前message在上一级repeated数组中的offset)，基于上一级的path不断拓展：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Parser::ParseTopLevelStatement(FileDescriptorProto* file,</span><br><span class="line">                                    <span class="keyword">const</span> LocationRecorder&amp; root_location) &#123;</span><br><span class="line"></span><br><span class="line">…… <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (LookingAt(<span class="string">"message"</span>)) &#123;</span><br><span class="line">	    LocationRecorder location(root_location,</span><br><span class="line">	      FileDescriptorProto::kMessageTypeFieldNumber, file-&gt;message_type_size());</span><br><span class="line">	    <span class="keyword">return</span> ParseMessageDefinition(file-&gt;add_message_type(), location);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">…… <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心过程在<code>Parser::ParseTopLevelStatement()</code>函数中： </p>
<p>Parser::ParseTopLevelStatement()每次处理一个大块完整的信息（完整的message/enum/service/extend/etc），每个块的处理过程是按照.proto文件的语法结构来逐层处理的。并且在最底层（叶结点）完成FileDescriptorProto以及对应成员信息的赋值。例如在message的’field’这一层完成lable/type/name/number的赋值。</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_compiler_parser_2.png" alt="avatar"></p>
<h3 id="类Parser-LocationRecorder"><a href="#类Parser-LocationRecorder" class="headerlink" title="类Parser::LocationRecorder"></a>类Parser::LocationRecorder</h3><p>类Parser的private类，记录SourceCodeInfo.location中的一个localtion ，RAII方式实现，constructor记录start位置，destructor记录end位置</p>
<p>核心数据成员：</p>
<pre><code>Parser* parser_;
SourceCodeInfo::Location* location_;
</code></pre><blockquote>
<p>Q： 从函数调用层级关系看：</p>
</blockquote>
<pre><code>SourceTreeDescriptorDatabase::FindFileByName(const string&amp; filename, FileDescriptorProto* output) -&gt;
Parser::Parse(io::Tokenizer* input, FileDescriptorProto* file) -&gt;
Parser::ParseTopLevelStatement(FileDescriptorProto* file, const LocationRecorder&amp; root_location)
</code></pre><blockquote>
<p><code>Parser::ParseTopLevelStatement(FileDescriptorProto* file, const LocationRecorder&amp; root_location)</code>函数中第一个参数 file并不是input数据（而是需要赋值的output数据），进入这个函数时，file并没有被填充内容，那么在函数内部为什么能够直接使用类似file-&gt;message_type_size()的调用来从file获取数据呢？</p>
<p>答案是这样：</p>
</blockquote>
<p>file在整个处理过程中，是一直会被写入的。当新处理一个子结构时，就会调用<code>FileDescriptorProto::add*()</code> 接口 产生一个新的子结构，所以从file读取数据时，获得的就是当前file的状态信息。具体看下面的例子，<code>file-&gt;message_type_size()</code>记录下的就是当前处理的message在整个<code>array&lt;message&gt;</code>中的offset，初始值为0。在调用<code>file-&gt;add_message_type()</code>之后，再次读取 <code>file-&gt;message_type_size()</code>的值就会+1了。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">bool</span> Parser::ParseTopLevelStatement(FileDescriptorProto* file,</span><br><span class="line">	                                    <span class="keyword">const</span> LocationRecorder&amp; root_location) &#123;</span><br><span class="line">	</span><br><span class="line">	…… <span class="comment">//省略</span></span><br><span class="line">	</span><br><span class="line">	  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LookingAt(<span class="string">"message"</span>)) &#123;</span><br><span class="line">	    LocationRecorder location(root_location,</span><br><span class="line">	      FileDescriptorProto::kMessageTypeFieldNumber, file-&gt;message_type_size());</span><br><span class="line">	    <span class="keyword">return</span> ParseMessageDefinition(file-&gt;add_message_type(), location);</span><br><span class="line">	</span><br><span class="line">	…… <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类SourceCodeInfo"><a href="#类SourceCodeInfo" class="headerlink" title="类SourceCodeInfo"></a>类SourceCodeInfo</h3><p>封装了关于proto源文件的信息，用于生成对应的FileDescriptorProto。定义在descriptor.proto 文件，作为一个Message子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message SourceCodeInfo &#123;</span><br><span class="line">	repeated Location location = <span class="number">1</span>;</span><br><span class="line">	message Location &#123;</span><br><span class="line">	    repeated int32 path = <span class="number">1</span> [packed=<span class="literal">true</span>];</span><br><span class="line">	    repeated int32 span = <span class="number">2</span> [packed=<span class="literal">true</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>span: 记录某个location在proto文件中的位置：[start_line, start_column,  end_line, end_column]</li>
<li>path: 记录某个location在整个proto文件层级路径（从FileDescriptorProto开始查找），其中包含了每一层的field number 以及对应的index(如果在上一层中是repeated类型表示)。</li>
</ol>
<h3 id="类SourceLocationTable"><a href="#类SourceLocationTable" class="headerlink" title="类SourceLocationTable"></a>类SourceLocationTable</h3><p>管理<code>pair&lt;descriptor, ErrorLocation&gt;</code> -&gt; <code>pair&lt;line,column&gt;</code>，核心数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;</span><br><span class="line">  pair&lt;<span class="keyword">const</span> Message*, DescriptorPool::ErrorCollector::ErrorLocation&gt;,</span><br><span class="line">  pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; LocationMap;</span><br><span class="line">LocationMap location_map_;</span><br></pre></td></tr></table></figure>
<h2 id="CodeGenerator相关"><a href="#CodeGenerator相关" class="headerlink" title="CodeGenerator相关"></a>CodeGenerator相关</h2><h3 id="类GeneratorContext"><a href="#类GeneratorContext" class="headerlink" title="类GeneratorContext"></a>类GeneratorContext</h3><p>接口类，表示CodeGenerator产生文件的路径和CodeGenerator运行的其它context信息。</p>
<h3 id="类GeneratorContextImpl"><a href="#类GeneratorContextImpl" class="headerlink" title="类GeneratorContextImpl"></a>类GeneratorContextImpl</h3><p>GeneratorContext类的子类，处理内存中的文件，并且output到磁盘上。一个独立的GeneratorContext对应一个output的地址，所以如果有2个generator对应同一个地址，那么需要共用同一个GeneratorContext。</p>
<h3 id="类CodeGenerator"><a href="#类CodeGenerator" class="headerlink" title="类CodeGenerator"></a>类CodeGenerator</h3><p>接口类，从.proto定义文件产生code。</p>
<p>OutputDirective结构体：描述需要输出的路径和对应的generator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output_directives_ lists all the files we are supposed to output and what</span></span><br><span class="line"><span class="comment">// generator to use for each.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutputDirective</span> &#123;</span>                                                                                                </span><br><span class="line">  <span class="built_in">string</span> name;                <span class="comment">// E.g. "--foo_out"</span></span><br><span class="line">  CodeGenerator* generator;   <span class="comment">// NULL for plugins</span></span><br><span class="line">  <span class="built_in">string</span> parameter;</span><br><span class="line">  <span class="built_in">string</span> output_location;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="built_in">vector</span>&lt;OutputDirective&gt; output_directives_;</span><br></pre></td></tr></table></figure>
<h3 id="相关类图"><a href="#相关类图" class="headerlink" title="相关类图"></a>相关类图</h3><p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_code_generator.png" alt="avatar"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/protobuf-reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/protobuf-reflection/" itemprop="url">Protobuf-Reflection类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-20T20:23:05+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类Reflection"><a href="#类Reflection" class="headerlink" title="类Reflection"></a>类Reflection</h2><p>接口类，提供方法来动态访问/修改message中的field的接口类。调用<code>Message::GetReflection()</code>获得messge对应的reflection。<br>这个类没有放到Message类中，是<code>从效率角度考虑</code>的。因为绝大多数message的实现共用同一套Reflection（GeneratedMessageReflection），并且一个Message所有的object是共享同一个reflection object的。</p>
<p>注意：  </p>
<ol>
<li>针对所有不同的field类型<code>FieldDescriptor::TYPE_*</code>,需要使用不同的<code>Get*()/Set*()/Add*()</code> 接口;</li>
<li>repeated类型需要使用<code>GetRepeated*()/SetRepeated*()</code>接口，不可以和非repeated类型接口混用；</li>
<li>message对象只可以被由它自身的<code>reflection（message.GetReflection()）</code>来操作；</li>
</ol>
<p>那么为什么需要针对每种<code>FieldDescriptor::TYPE_*</code>有单独的<code>Get*()/Set*()</code>呢？<br>因为如果使用抽象的type来解决，需要增加一层处理，这会导致message占用内存变大，也增加了内存泄漏的风险，所以在用这种flat的接口设计。</p>
<h2 id="类GeneratedMessageReflection"><a href="#类GeneratedMessageReflection" class="headerlink" title="类GeneratedMessageReflection"></a>类GeneratedMessageReflection</h2><p>类Reflection的子类（也是当前版本中唯一的子类），服务于某一个固定的descriptor（构造GeneratedMessageReflection对象时就确定了对应的descriptor）。反射机制中最为核心的类。</p>
<h3 id="内部实现："><a href="#内部实现：" class="headerlink" title="内部实现："></a>内部实现：</h3><p>操作任何一个数据时，需要知道2个信息即可：</p>
<ol>
<li>内存地址；</li>
<li>类型信息;</li>
</ol>
<p>GeneratedMessageReflection也是这样设计的。GeneratedMessageReflection通过<code>base_addr + $offset[i]</code> 的方式管理message所有的field，<code>$offset[i]</code>记录了message中每个field在message内存对象中的偏移，并且descriptor中有每个field的类型信息。</p>
<blockquote>
<p>需要针对某个(message, field)做处理的时候：</p>
</blockquote>
<ol>
<li>直接通过descriptor获取对应field在message中的index</li>
<li>再查询offset[$index]获取内存地址</li>
<li>然后通过descriptor中type信息</li>
<li>做reinterpret_cast就获得对应数据。</li>
</ol>
<blockquote>
<p>构建GeneratedMessageReflection对象时，传入的核心数据是： </p>
</blockquote>
<ol>
<li>descriptor：被管理的message的descriptor指针；</li>
<li>offsets：message类的所有成员在message类内存对象的偏移；</li>
<li><code>has_bits_offset</code>： 用于”记录某个field是否存在的bitmap”的偏移（这个bitmap是message子类内部成员，其实是取这个数组0元素<code>_has_bits_[0]</code>的偏移）,这个bitmap最终是用来判断optional类型的field是否存在；</li>
<li><code>unknown_fields_offset</code>： 和<code>has_bits_offset</code>功能类似，用于记录unkown数据；</li>
</ol>
<blockquote>
<p>field有不同的类型，所以需要将<code>void*</code>转化为相应的类型。</p>
</blockquote>
<ol>
<li>对于primitive类型和string类型，直接使用对应primitive类型/string*表示；</li>
<li>单个Message类型field，通过Message的指针来保存；</li>
<li>Enum类型field，通过int来保存，这个int作为EnumDescriptor::FindValueByNumber()的输入；</li>
<li>Repeated类型field（细节见《repeated字段》一章）：</li>
<li>其中Strings/Message类型使用RepeatedPtrFields</li>
<li>其它primitive类型使用RepeatedFields</li>
</ol>
<h3 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h3><p>在每个.pb.cc文件中，对应每个message都有对应的<code>GeneratedMessageReflection</code>对象。例如针对<code>protobuf/compiler/plugin.proto</code>文件中的message CodeGeneratorRequest，在<code>protobuf/compiler/plugin.pb.cc</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ::google::protobuf::Descriptor* CodeGeneratorRequest_descriptor_ = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> ::google::protobuf::internal::GeneratedMessageReflection*</span><br><span class="line">  CodeGeneratorRequest_reflection_ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">…… <span class="comment">//省略</span></span><br><span class="line">                                                                                                                          </span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line">…… <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protobuf_AssignDesc_google_2fprotobuf_2fcompiler_2fplugin_2eproto</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">…… <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// CodeGeneratorRequest包含这3个field</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CodeGeneratorRequest_offsets_[<span class="number">3</span>] = &#123;                                                                                                                     </span><br><span class="line">    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, file_to_generate_),</span><br><span class="line">    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, parameter_),</span><br><span class="line">    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, proto_file_),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  CodeGeneratorRequest_reflection_ =</span><br><span class="line">    <span class="keyword">new</span> ::google::protobuf::internal::GeneratedMessageReflection(</span><br><span class="line">      CodeGeneratorRequest_descriptor_,</span><br><span class="line">      CodeGeneratorRequest::default_instance_,</span><br><span class="line">      CodeGeneratorRequest_offsets_,</span><br><span class="line">      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, _has_bits_[<span class="number">0</span>]),</span><br><span class="line">      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, _unknown_fields_),</span><br><span class="line">      <span class="number">-1</span>,  </span><br><span class="line">      ::google::protobuf::DescriptorPool::generated_pool(),</span><br><span class="line">      ::google::protobuf::MessageFactory::generated_factory(),</span><br><span class="line">      <span class="keyword">sizeof</span>(CodeGeneratorRequest));</span><br><span class="line"></span><br><span class="line">…… <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GOOGLE-PROTOBUF-GENERATED-MESSAGE-FIELD-OFFSET宏"><a href="#GOOGLE-PROTOBUF-GENERATED-MESSAGE-FIELD-OFFSET宏" class="headerlink" title="GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET宏"></a><code>GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET</code>宏</h3><p><code>GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET</code>宏作用是找到某个field在所被包含type内存的offset</p>
<blockquote>
<p>Q：pb.h定义中，field都是message子类的private成员，这里为什么可以通过”-&gt;”访问private成员呢？</p>
<p>A: 函数<code>protobuf_AssignDesc_google_2fprotobuf_2fcompiler_2fplugin_2eproto()</code>被定义为各个message子类的friend（定义在private部分）</p>
</blockquote>
<p>这里代码注释给了很多信息！protobuf针对关键点的注释非常详细，值得学习！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the offset of the given field within the given aggregate type.</span></span><br><span class="line"><span class="comment">// This is equivalent to the ANSI C offsetof() macro.  However, according</span></span><br><span class="line"><span class="comment">// to the C++ standard, offsetof() only works on POD types, and GCC</span></span><br><span class="line"><span class="comment">// enforces this requirement with a warning.  In practice, this rule is</span></span><br><span class="line"><span class="comment">// unnecessarily strict; there is probably no compiler or platform on</span></span><br><span class="line"><span class="comment">// which the offsets of the direct fields of a class are non-constant.</span></span><br><span class="line"><span class="comment">// Fields inherited from superclasses *can* have non-constant offsets,</span></span><br><span class="line"><span class="comment">// but that's not what this macro will be used for.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that we calculate relative to the pointer value 16 here since if we</span></span><br><span class="line"><span class="comment">// just use zero, GCC complains about dereferencing a NULL pointer.  We</span></span><br><span class="line"><span class="comment">// choose 16 rather than some other number just in case the compiler would</span></span><br><span class="line"><span class="comment">// be confused by an unaligned pointer.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TYPE, FIELD)    \</span></span><br><span class="line">  <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(                                           \</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(                            \</span><br><span class="line">      &amp;<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> TYPE*&gt;(<span class="number">16</span>)-&gt;FIELD) -            \</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="number">16</span>))</span><br></pre></td></tr></table></figure>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>以primitive类型为例说明GeneratedMessageReflection如何管理各个不同类型的field。</p>
<h4 id="在read一侧："><a href="#在read一侧：" class="headerlink" title="在read一侧："></a>在read一侧：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Template implementations of basic accessors.  Inline because each</span></span><br><span class="line"><span class="comment">// template instance is only called from one location.  These are</span></span><br><span class="line"><span class="comment">// used for all types except messages.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Type&amp; GeneratedMessageReflection::GetField(</span><br><span class="line">    <span class="keyword">const</span> Message&amp; message, <span class="keyword">const</span> FieldDescriptor* field) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> GetRaw&lt;Type&gt;(message, field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从message内存起始地址，按照field在message对象内存中的offset偏移之后获取field的内存地址，然后<code>reinterpret_cast</code>为Type类型（primitive的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These simple template accessors obtain pointers (or references) to</span></span><br><span class="line"><span class="comment">// the given field.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Type&amp; GeneratedMessageReflection::GetRaw(                                                                    </span><br><span class="line">    <span class="keyword">const</span> Message&amp; message, <span class="keyword">const</span> FieldDescriptor* field) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8*&gt;(&amp;message) +</span><br><span class="line">                    offsets_[field-&gt;index()];</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> Type*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>offsets_[]</code>就是构造函数<code>GeneratedMessageReflection::GeneratedMessageReflection()</code>传入的，各个field在message中的偏移量数组（也就是上面例子中的 <code>CodeGeneratorRequest_offsets_[3]</code>）。<code>field-&gt;index()</code>是field在parent的children数组中的pos，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">			<span class="keyword">inline</span> <span class="keyword">int</span> FieldDescriptor::index() <span class="keyword">const</span> &#123;</span><br><span class="line">				...... <span class="comment">//省略</span></span><br><span class="line">			    <span class="keyword">return</span> <span class="keyword">this</span> - containing_type_-&gt;fields_;</span><br><span class="line">				...... <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在write一侧："><a href="#在write一侧：" class="headerlink" title="在write一侧："></a>在write一侧：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> GeneratedMessageReflection::SetField(</span><br><span class="line">    Message* message, <span class="keyword">const</span> FieldDescriptor* field, <span class="keyword">const</span> Type&amp; value) <span class="keyword">const</span> &#123;</span><br><span class="line">  *MutableRaw&lt;Type&gt;(message, field) = value;</span><br><span class="line">  SetBit(message, field);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">inline</span> Type* GeneratedMessageReflection::MutableRaw(</span><br><span class="line">    Message* message, <span class="keyword">const</span> FieldDescriptor* field) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">void</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;uint8*&gt;(message) + offsets_[field-&gt;index()];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Type*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里has_bits_offset_为bitmap结构，通过某个bit是否存在，快速判断对应filed是否存在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> GeneratedMessageReflection::SetBit(</span><br><span class="line">    Message* message, <span class="keyword">const</span> FieldDescriptor* field) <span class="keyword">const</span> &#123;</span><br><span class="line">  MutableHasBits(message)[field-&gt;index() / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (field-&gt;index() % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> uint32* GeneratedMessageReflection::MutableHasBits(</span><br><span class="line">    Message* message) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">void</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;uint8*&gt;(message) + has_bits_offset_;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;uint32*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RepeatedPtrFields / RepeatedFields</code>具体实现，见repeated_field.*文件，详情见《repeated字段》一章</p>
<h3 id="内存分布说明"><a href="#内存分布说明" class="headerlink" title="内存分布说明"></a>内存分布说明</h3><p>举一个具体的例子来说明<code>offset[]</code>的工作方式吧：</p>
<ol>
<li>从message Student定义到对应class Student</li>
<li>再到offset以及Student类对象内存分布说明，请见下图：</li>
</ol>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_reflection_array_demo.png" alt="avatar"></p>
<h4 id="Message类对象内存分布"><a href="#Message类对象内存分布" class="headerlink" title="Message类对象内存分布"></a>Message类对象内存分布</h4><p>针对不同类型，有不同的内存记录方式：</p>
<ol>
<li>primitve类型：直接在内存中保存了对应的value；</li>
<li>string类型，保存的是string*地址；</li>
<li><code>repeated&lt;message&gt;</code>类型，保存的是<code>RepeatedPtrField&lt;message&gt;</code>对象，采用2级内存管理，第一级内部数据管理的是<code>array&lt;void*&gt;</code>，<code>void*</code>是真实message对象内存地址</li>
<li><code>repeated&lt;primitive&gt;</code>类型，保存的是<code>RepeatedField&lt;primitive&gt;</code>对象,内部数据管理的是<code>array&lt;primitive数据对象&gt;</code></li>
</ol>
<p>Student类中包含了多种类型成员，对应内存查找过程如下图所示：</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_reflection_memory.png" alt="avatar"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/protobuf-repeated/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/protobuf-repeated/" itemprop="url">Protobuf-Repeated相关类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-19T22:16:07+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Repeated类型"><a href="#Repeated类型" class="headerlink" title="Repeated类型"></a>Repeated类型</h4><p>field包含2种类型：</p>
<ul>
<li>Strings/Message类型使用RepeatedPtrFields</li>
<li>enum / primitive类型使用RepeatedFields</li>
</ul>
<p>核心类关系图如下：</p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_repeated_class_diagram.png" alt="avatar"></p>
<h4 id="类RepeatedField"><a href="#类RepeatedField" class="headerlink" title="类RepeatedField"></a>类RepeatedField</h4><p>模板类，为primitive类型数据提供repeated类型容器。内部实现为连续内存的array（保存的内容就是primitive对象），并且对外提供iterator方式来访问。   </p>
<p>array起始大小为4(static const int kInitialSize = 4;)，当长度不够的时候会分配新的内存（max(total_size_ * 2, new_size)）以及内存拷贝，所以如果repeated的成员很多，使用Reserve()接口能节省array增大时的内存分配和数据拷贝成本。</p>
<h4 id="类RepeatedPtrFieldBase"><a href="#类RepeatedPtrFieldBase" class="headerlink" title="类RepeatedPtrFieldBase"></a>类RepeatedPtrFieldBase</h4><p>RepeatedPtrFields的父类（不是模板类，提供了多个模板函数），本身保存/管理的数据类型为void*（message对象的实际地址，也是通过连续内存array来保存）。</p>
<p>RepeatedPtrFieldBase类并不感知自己管理的具体是什么message，通过模板函数的模板参数TypeHandler来为各种数据类型数据提供服务，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> TypeHandler&gt;</span><br><span class="line">	<span class="keyword">void</span> RepeatedPtrFieldBase::Clear() &#123;</span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; current_size_; i++) &#123;</span><br><span class="line">	    TypeHandler::Clear(cast&lt;TypeHandler&gt;(elements_[i]));</span><br><span class="line">	  &#125;</span><br><span class="line">	  current_size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为array中保存的是同一个descriptor对应的message，只是各个message中所包含的数据不一样，为了节省下message对象分配/删除的成本，所以message可以被clear(clear操作会将primitive类型的field设置为0，其余类型field调用自身的clear()接口处理，例如string类型的std::string::clear(),只清理数据并不回收内存)，然后保留原有的内存地址在array中。下次需要从array中分配message时，优先使用这一批被clear的message（实现在RepeatedPtrFieldBase::AddFromCleared() ，参考GeneratedMessageReflection::AddMessage()中的调用方式）。<br>为了管理cleared状态的message指针，引入了多个游标来标记数据：</p>
<ul>
<li>current_size_: 当前待处理的message地址；</li>
<li>allocated_size_:已经分配message的数据，current_size_ &lt;= allocated_size_，从current_size_到allocated_size_之间的message就是被cleared的；</li>
<li>total_size_: elements_[]的长度，但从allocated_size_到total_size_之间的void*是无效的，并没有指向任何message；</li>
</ul>
<p>对应内存分布如下：<br><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_repeated_memory.png" alt="avatar"></p>
<h4 id="类RepeatedPtrField"><a href="#类RepeatedPtrField" class="headerlink" title="类RepeatedPtrField"></a>类RepeatedPtrField</h4><p>模板类，RepeatedPtrFieldBase的子类，为Strings/Message类型数据提供repeated类型容器。</p>
<blockquote>
<p>Q: 这里RepeatedPtrField类是RepeatedPtrFieldBase类唯一的子类，是否也没有必要这样区分父类/子类呢？<br>Answer如下：</p>
</blockquote>
<h6 id="提前铺垫（父类-子类的分工）："><a href="#提前铺垫（父类-子类的分工）：" class="headerlink" title="提前铺垫（父类/子类的分工）："></a>提前铺垫（父类/子类的分工）：</h6><ul>
<li>RepeatedPtrFieldBase（非模板类，提供模板函数）负责的是最基本的基于array&lt;void*&gt;的操作，并不感知所保存的内容的数据类型，所有需要区分类型的操作都有模板类型TypeHandler来负责；</li>
<li>RepeatedPtrField（模板类）感知数据类型(数据类型由模板参数Element提供)，并且对外的接口都是基于类型Element的。针对Element的操作则由TypeHandler来负责，并且通过父类RepeatedPtrFieldBase模板函数的参数传递给父类。  </li>
</ul>
<p>这种分工可以在RepeatedPtrField<element>的很多函数上体现，例如：</element></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> RepeatedPtrField&lt;Element&gt;::RemoveLast() &#123;</span><br><span class="line">	 RepeatedPtrFieldBase::RemoveLast&lt;TypeHandler&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="本质原因："><a href="#本质原因：" class="headerlink" title="本质原因："></a>本质原因：</h6><p>某些情况下无法感知子类(模板类)RepeatedPtrField<element>的模板参数Element，所以并不清楚具体子类，只能指向父类RepeatedPtrFieldBase。  </element></p>
<p>例如在GeneratedMessageReflection::AddMessage()中，其实message子类中保存的是RepeatedPtrField<element>对象（可以参考student.proto中的例子），所以只能将使用父类RepeatedPtrFieldBase指针指向RepeatedPtrField<element>的对象，然后：  </element></element></p>
<ol>
<li>调用RepeatedPtrFieldBase::AddFromCleared<typehandler>()，尝试获取已cleared但未释放的message对象。如果没有，就继续；</typehandler></li>
<li>获取一个prototype（指向真实Message子类对象的父类Message指针）：<br>   (2.1)先看RepeatedPtrFieldBase的array&lt;RepeatedPtrField<element> &gt;是否有成员，如果有就使用;<br>   (2.2)调用factory-&gt;GetPrototype()创建一个；</element></li>
<li>调用prototype（指向真实Message子类对象的父类Message指针）的Message::New()接口，创建出一个真实field_descriptor对应的Message子类对象；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Message* GeneratedMessageReflection::AddMessage(</span><br><span class="line">    Message* message, <span class="keyword">const</span> FieldDescriptor* field,</span><br><span class="line">    MessageFactory* factory) <span class="keyword">const</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略非核心代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can't use AddField&lt;Message&gt;() because RepeatedPtrFieldBase doesn't</span></span><br><span class="line">    <span class="comment">// know how to allocate one.</span></span><br><span class="line">    RepeatedPtrFieldBase* repeated =</span><br><span class="line">      MutableRaw&lt;RepeatedPtrFieldBase&gt;(message, field);</span><br><span class="line">    Message* result = repeated-&gt;AddFromCleared&lt;GenericTypeHandler&lt;Message&gt; &gt;();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// We must allocate a new object.</span></span><br><span class="line">      <span class="keyword">const</span> Message* prototype;</span><br><span class="line">      <span class="keyword">if</span> (repeated-&gt;size() == <span class="number">0</span>) &#123;</span><br><span class="line">        prototype = factory-&gt;GetPrototype(field-&gt;message_type());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prototype = &amp;repeated-&gt;Get&lt;GenericTypeHandler&lt;Message&gt; &gt;(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = prototype-&gt;New();</span><br><span class="line">      repeated-&gt;AddAllocated&lt;GenericTypeHandler&lt;Message&gt; &gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>Q：这里的TypeHandler是在哪里定义的呢？类RepeatedPtrField中并没有提供接口来针对不同数据类型设置typehandler?  
</code></pre><p> Answer如下：</p>
</blockquote>
<p>定义在repeated_field.h中，根据模板类RepeatedPtrField&lt;&gt;模板参数的不同（Element或者string），继承了不同的父类（因为这里子类自己并没有独有的数据/行为，所以用这种方式来选择使用哪种handler）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepeatedPtrField</span>&lt;Element&gt;:</span>:TypeHandler</span><br><span class="line">    : <span class="keyword">public</span> internal::GenericTypeHandler&lt;Element&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepeatedPtrField</span>&lt;string&gt;:</span>:TypeHandler</span><br><span class="line">    : <span class="keyword">public</span> internal::StringTypeHandler &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>typehandler是直接子类RepeatedPtrField在调用父类RepeatedPtrFieldBase的模板函数时，通过模板参数直接传入父类RepeatedPtrFieldBase，可以通过GeneratedMessageReflection中使用的例子来看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Message&amp; GeneratedMessageReflection::GetRepeatedMessage(</span><br><span class="line">    <span class="keyword">const</span> Message&amp; message, <span class="keyword">const</span> FieldDescriptor* field, <span class="keyword">int</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">     …… <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> GetRaw&lt;RepeatedPtrFieldBase&gt;(message, field)</span><br><span class="line">        .Get&lt;GenericTypeHandler&lt;Message&gt; &gt;(index);                                                                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板函数RepeatedPtrFieldBase::Get<typehandler>()，这里的TypeHandler就是GenericTypeHandler<message>：</message></typehandler></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TypeHandler&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> TypeHandler::Type&amp;</span><br><span class="line">RepeatedPtrFieldBase::Get(<span class="keyword">int</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">  GOOGLE_DCHECK_LT(index, size());</span><br><span class="line">  <span class="keyword">return</span> *cast&lt;TypeHandler&gt;(elements_[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里TypeHandler是RepeatedPtrField类的protected成员，为了不让用户再将RepeatedPtrField作为父类来使用：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Note:  RepeatedPtrField SHOULD NOT be subclassed by users.  We only</span></span><br><span class="line"><span class="comment">//   subclass it in one place as a hack for compatibility with proto1.  The</span></span><br><span class="line"><span class="comment">//   subclass needs to know about TypeHandler in order to call protected</span></span><br><span class="line"><span class="comment">//   methods on RepeatedPtrFieldBase.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TypeHandler</span>;</span></span><br></pre></td></tr></table></figure>
<h4 id="类GenericTypeHandler"><a href="#类GenericTypeHandler" class="headerlink" title="类GenericTypeHandler"></a>类GenericTypeHandler</h4><p>针对message的typehandler</p>
<h4 id="类StringTypeHandler"><a href="#类StringTypeHandler" class="headerlink" title="类StringTypeHandler"></a>类StringTypeHandler</h4><p>StringTypeHandlerBase的子类，在父类基础上增加了SpaceUsed()接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">LIBPROTOBUF_EXPORT</span> <span class="title">StringTypeHandler</span> :</span> <span class="keyword">public</span> StringTypeHandlerBase &#123;</span><br><span class="line">	 <span class="keyword">public</span>:</span><br><span class="line">	  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SpaceUsed</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; value)</span>  </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">sizeof</span>(value) + StringSpaceUsedExcludingSelf(value);</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要理解string的数据结构来理解这段代码了，从代码看start/end是保存在string对象的前第一/前第二个位置<code>void*</code>（sizeof(void*)为8个byte）的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StringSpaceUsedExcludingSelf</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* start = &amp;str;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* end = &amp;str + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (start &lt;= str.data() &amp;&amp; str.data() &lt;= end) &#123;</span><br><span class="line">    <span class="comment">// The string's data is stored inside the string object itself.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str.capacity();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Q: 为什么需要区分父类/子类呢？直接使用StringTypeHandler即可啊</p>
<p>Answer如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HACK:  If a class is declared as DLL-exported in MSVC, it insists on</span></span><br><span class="line"><span class="comment">//   generating copies of all its methods -- even inline ones -- to include</span></span><br><span class="line"><span class="comment">//   in the DLL.  But SpaceUsed() calls StringSpaceUsedExcludingSelf() which</span></span><br><span class="line"><span class="comment">//   isn't in the lite library, therefore the lite library cannot link if</span></span><br><span class="line"><span class="comment">//   StringTypeHandler is exported.  So, we factor out StringTypeHandlerBase,                                                                                               </span></span><br><span class="line"><span class="comment">//   export that, then make StringTypeHandler be a subclass which is NOT</span></span><br><span class="line"><span class="comment">//   exported.</span></span><br><span class="line"><span class="comment">// TODO(kenton):  There has to be a better way.</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/13/protobuf-unknown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/protobuf-unknown/" itemprop="url">Protobuf-Unknown字段</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-13T10:09:16+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="待解决的问题："><a href="#待解决的问题：" class="headerlink" title="待解决的问题："></a>待解决的问题：</h3><p>分布式系统中，各个模块接口之间proto文件在升级过程中，必然会存在版本不一致的情况。<br>unknown字段，用于解决proto文件升级过程中，在多级联关系的各个模块（特别是涉及路由功能模块传递数据时）接口之间proto版本不一致，而导致数据无法传递的问题。</p>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><p>之前在hy-new-router重构项目开发中，就遇到这样的问题。利用driver向asp发送消息，消息到了hy-ui解析失败。<br>Asp/hy-router/hy-ui 3个模块之间通信是使用厂内历史留存的idl方式定义的，按照包含字段的内容，v1&gt;v3&gt;v2（v2的数据内容最少，虽然看上去各个字段差异部分都是使用了optional方式做了兼容），hy-router按照v2解析后，传递给下游hy-ui。  </p>
<p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_unkown.png" alt="avatar"></p>
<h3 id="解决的思路："><a href="#解决的思路：" class="headerlink" title="解决的思路："></a>解决的思路：</h3><p>parse数据时，如果发现某个field_id不在本模块接口定义proto中，那么将这个field保存到unknown字段中，在后续处理 serialize过程中，会将unkown字段继续传递下去。</p>
<h3 id="具体技术实现："><a href="#具体技术实现：" class="headerlink" title="具体技术实现："></a>具体技术实现：</h3><h4 id="类UnknownField"><a href="#类UnknownField" class="headerlink" title="类UnknownField"></a>类UnknownField</h4><p>记录unknown字段的key（field_id,数据类型）和value。针对不同type数据，使用union方式实现。涉及到非primitive类型数据，考虑了DeepCopy。</p>
<p>key： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type &#123;</span><br><span class="line">  TYPE_VARINT,</span><br><span class="line">  TYPE_FIXED32,</span><br><span class="line">  TYPE_FIXED64,</span><br><span class="line">  TYPE_LENGTH_DELIMITED,</span><br><span class="line">  TYPE_GROUP</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> number_ : <span class="number">29</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> type_   : <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>value：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">  uint64 varint_;</span><br><span class="line">  uint32 fixed32_;</span><br><span class="line">  uint64 fixed64_;</span><br><span class="line">  <span class="built_in">string</span>* length_delimited_;</span><br><span class="line">  UnknownFieldSet* group_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="类UnknownFieldSet"><a href="#类UnknownFieldSet" class="headerlink" title="类UnknownFieldSet"></a>类UnknownFieldSet</h4><p>  <code>vector&lt;UnknownField&gt;</code> 方式记录UnknownField。</p>
<h4 id="message处理中的实现"><a href="#message处理中的实现" class="headerlink" title="message处理中的实现"></a>message处理中的实现</h4><p>所有具体message子类中，包含了对应unkown字段以及访问方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class LIBPROTOC_EXPORT CodeGeneratorRequest : public ::google::protobuf::Message &#123;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">  inline const ::google::protobuf::UnknownFieldSet&amp; unknown_fields() const &#123;</span><br><span class="line">    return _unknown_fields_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">…… //省略</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">  ::google::protobuf::UnknownFieldSet _unknown_fields_;</span><br><span class="line">…… //省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>message对应的reflection也可以访问到对应unknown字段，访问方式和其它reflection功能一样，通过<code>base + offset偏移</code>方式获取到对应内存地址，然后reinterpret_cast。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UnknownFieldSet&amp; GeneratedMessageReflection::GetUnknownFields(</span><br><span class="line">    <span class="keyword">const</span> Message&amp; message) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> uint8*&gt;(&amp;message) +</span><br><span class="line">                    unknown_fields_offset_;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> UnknownFieldSet*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>unknown_fields_offset_</code>是在构造<code>GeneratedMessageReflection</code>时传递的，在每个由protoc产生的pb.cc中都会有，例如compiler/plugin.pb.cc 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CodeGeneratorRequest_reflection_ =</span><br><span class="line">  <span class="keyword">new</span> ::google::protobuf::internal::GeneratedMessageReflection(</span><br><span class="line">    CodeGeneratorRequest_descriptor_,</span><br><span class="line">    CodeGeneratorRequest::default_instance_,</span><br><span class="line">    CodeGeneratorRequest_offsets_,</span><br><span class="line">    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, _has_bits_[<span class="number">0</span>]),</span><br><span class="line">    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeGeneratorRequest, _unknown_fields_),</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    ::google::protobuf::DescriptorPool::generated_pool(),</span><br><span class="line">    ::google::protobuf::MessageFactory::generated_factory(),</span><br><span class="line">    <span class="keyword">sizeof</span>(CodeGeneratorRequest));</span><br></pre></td></tr></table></figure>
<p>parse数据过程中，代码调用关系梳理如下。</p>
<ol>
<li>MessageLite::ParseFromString() -&gt;</li>
<li>InlineParseFromArray() -&gt;</li>
<li>InlineMergeFromCodedStream() -&gt;</li>
<li>Message::MergePartialFromCodedStream() -&gt;</li>
<li>WireFormat::ParseAndMergePartial() -&gt;</li>
<li>WireFormat::ParseAndMergeField() -&gt;</li>
<li>WireFormat::SkipField()</li>
</ol>
<p>核心部分在WireFormat::ParseAndMergePartial() 开始：  </p>
<ol>
<li>while循环中从io::CodedInputStream* input中逐个读取tag；</li>
<li>从tag提取<code>field_number</code>，由<code>field_number</code>从<code>Descriptor*</code>查找FieldDescriptor*；</li>
<li>如果找不到<code>field_number</code>，WireFormat::ParseAndMergeField()中获取Reflection* message_reflection，再通过GeneratedMessageReflection::GetUnknownFields()获得unknown字段；</li>
<li>WireFormat::SkipField()中，根据field_type,调用UnknownFieldSet不同方法；</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/12/protobuf-descriptor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/protobuf-descriptor/" itemprop="url">Protobuf-Descriptor相关类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T23:07:40+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类Descriptor"><a href="#类Descriptor" class="headerlink" title="类Descriptor"></a>类Descriptor</h2><p>描述一种message类型（不是一个单独的message对象）的meta信息。构造函数是private类型，必须通过DescriptorPool（friend类）来构造。</p>
<h4 id="const的成员："><a href="#const的成员：" class="headerlink" title="const的成员："></a>const的成员：</h4><ol>
<li><code>const FileDescriptor* file_</code>： 描述message所在的.proto文件信息</li>
<li><code>const Descriptor* containing_type_</code>：如果在proto定义中，这个message是被其它message所包含，那么这个字段是上一级message的<code>descriptor*</code>；如果没有被包含，那么是NULL</li>
<li><code>const MessageOptions* options_</code>： 定义在descriptor.proto，从注释看是用来和老版本proto1中MessageSet做拓展，可以先不去关注涉及extension的部分。</li>
</ol>
<h4 id="非const的成员："><a href="#非const的成员：" class="headerlink" title="非const的成员："></a>非const的成员：</h4><ol>
<li><code>int field_count_</code>：当前field包含的field的个数</li>
<li><code>FieldDescriptor* fields_</code>： 以连续数组方式保存的所有的fieds</li>
<li><code>int nested_type_count_</code>: 嵌套类型数量</li>
<li><code>Descriptor* nested_types_</code>: message中嵌套message</li>
<li><code>int enum_type_count_</code>： 内部enum的个数</li>
<li><code>EnumDescriptor* enum_types_</code>： enum类型的连续内存起始地址</li>
</ol>
<h2 id="类FileDescriptor"><a href="#类FileDescriptor" class="headerlink" title="类FileDescriptor"></a>类FileDescriptor</h2><p>描述整个.proto文件信息，其中包含：</p>
<ol>
<li><p>依赖.proto文件信息：</p>
<p> <code>int dependency_count_;</code></p>
<p> <code>const FileDescriptor** dependencies_;</code></p>
</li>
<li><p>当前.proto文件包含的message信息：</p>
<p> <code>int message_type_count_;</code></p>
<p> <code>Descriptor* message_types_;</code></p>
</li>
<li><p>当前.proto文件包含的所有symbol (各种descriptor)的tables：</p>
<p> <code>const FileDescriptorTables* tables_;</code></p>
</li>
</ol>
<h2 id="类FieldDescriptor"><a href="#类FieldDescriptor" class="headerlink" title="类FieldDescriptor"></a>类FieldDescriptor</h2><p>描述一个单独的field，构造函数为private，也必须由<code>DescriptorPool</code>（friend类）构造。通过包含这个field的message的descriptor的函数（<code>Descriptor::FindFieldByName()</code>）获得。</p>
<h3 id="enum类型："><a href="#enum类型：" class="headerlink" title="enum类型："></a>enum类型：</h3><pre><code>enum Type ： field类型；
enum CppType： cpp中field类型，CppType和Type类型映射关系是固定的；
enum Label ：标记field的存在性类型(optional/required/repeated)；
</code></pre><h3 id="const类型的private数据："><a href="#const类型的private数据：" class="headerlink" title="const类型的private数据："></a>const类型的private数据：</h3><pre><code>const Descriptor* containing_type_;
const Descriptor* extension_scope_;
const Descriptor* message_type_;
const EnumDescriptor* enum_type_;
const FieldDescriptor* experimental_map_key_;
const FieldOptions* options_;
</code></pre><h3 id="3个映射表（static-const类型）："><a href="#3个映射表（static-const类型）：" class="headerlink" title="3个映射表（static const类型）："></a>3个映射表（static const类型）：</h3><pre><code>static const CppType kTypeToCppTypeMap[MAX_TYPE + 1];
static const char * const kTypeToName[MAX_TYPE + 1];
static const char * const kLabelToName[MAX_LABEL + 1];
</code></pre><p>在descriptor.cc中，实现对外暴露数据的函数时，为了提高代码可读性，使用了如下宏的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_int32 , int32 )</span><br><span class="line">PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, has_default_value, <span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure>
<p><code>PROTOBUF_DEFINE_ACCESSOR</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These macros makes this repetitive code more readable.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTOBUF_DEFINE_ACCESSOR(CLASS, FIELD, TYPE) \</span></span><br><span class="line">  <span class="keyword">inline</span> TYPE CLASS::FIELD() <span class="keyword">const</span> &#123; <span class="keyword">return</span> FIELD##_; &#125;</span><br></pre></td></tr></table></figure>
<p>因为FieldDescriptor自己包含如下union数据成员，用来表示不同TYPE类型数据的default值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">bool</span> has_default_value_;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    int32  default_value_int32_;</span><br><span class="line">    int64  default_value_int64_;</span><br><span class="line">    uint32 default_value_uint32_;</span><br><span class="line">    uint64 default_value_uint64_;</span><br><span class="line">    <span class="keyword">float</span>  default_value_float_;</span><br><span class="line">    <span class="keyword">double</span> default_value_double_;</span><br><span class="line">    <span class="keyword">bool</span>   default_value_bool_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> EnumValueDescriptor* default_value_enum_;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>* default_value_string_;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类EnumDescriptor"><a href="#类EnumDescriptor" class="headerlink" title="类EnumDescriptor"></a>类EnumDescriptor</h2><p>描述在.proto文件中定义的enum类型</p>
<h2 id="结构体Symbol"><a href="#结构体Symbol" class="headerlink" title="结构体Symbol"></a>结构体Symbol</h2><p>针对protobuf中7种类型的descriptor的一个封装。<br>编程上，也适用union来适配不同类型的descriptor：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Type type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Descriptor* descriptor;</span><br><span class="line">  <span class="keyword">const</span> FieldDescriptor* field_descriptor;</span><br><span class="line">  <span class="keyword">const</span> EnumDescriptor* enum_descriptor;</span><br><span class="line">  <span class="keyword">const</span> EnumValueDescriptor* enum_value_descriptor;</span><br><span class="line">  <span class="keyword">const</span> ServiceDescriptor* service_descriptor;</span><br><span class="line">  <span class="keyword">const</span> MethodDescriptor* method_descriptor;</span><br><span class="line">  <span class="keyword">const</span> FileDescriptor* package_file_descriptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>提高代码可读性上，使用宏的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTRUCTOR(TYPE, TYPE_CONSTANT, FIELD)  \</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">Symbol</span><span class="params">(<span class="keyword">const</span> TYPE* value)</span> </span>&#123;    \</span><br><span class="line">    type = TYPE_CONSTANT;                        \</span><br><span class="line">    <span class="keyword">this</span>-&gt;FIELD = value;                         \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CONSTRUCTOR(Descriptor         , MESSAGE   , descriptor             )</span><br><span class="line">  CONSTRUCTOR(FieldDescriptor    , FIELD     , field_descriptor       )</span><br><span class="line">  CONSTRUCTOR(EnumDescriptor     , ENUM      , enum_descriptor        )</span><br><span class="line">  CONSTRUCTOR(EnumValueDescriptor, ENUM_VALUE, enum_value_descriptor  )</span><br><span class="line">  CONSTRUCTOR(ServiceDescriptor  , SERVICE   , service_descriptor     )</span><br><span class="line">  CONSTRUCTOR(MethodDescriptor   , METHOD    , method_descriptor      )</span><br><span class="line">  CONSTRUCTOR(FileDescriptor     , PACKAGE   , package_file_descriptor)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CONSTRUCTOR</span></span><br></pre></td></tr></table></figure>
<h2 id="类DescriptorPool-Tables"><a href="#类DescriptorPool-Tables" class="headerlink" title="类DescriptorPool::Tables"></a>类DescriptorPool::Tables</h2><p>各种数据表的集合，封装 了一系列的hashmap结构。<br>注意这个类是descriptor.h文件中在类<code>DescriptorPool</code>的private成员中声明的，所以是类<code>DescriptorPool</code>内部的数据结构，</p>
<p><strong>封装的一系列的hashmap：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; PointerStringPair;</span><br><span class="line"><span class="comment">//这里是将message对应的descriptor地址和int组合在一起，指定descriptor中的某一个field</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Descriptor*, <span class="keyword">int</span>&gt; DescriptorIntPair;    </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> EnumDescriptor*, <span class="keyword">int</span>&gt; EnumIntPair;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, Symbol,</span><br><span class="line">                 hash&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;, streq&gt;</span><br><span class="line">  SymbolsByNameMap;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;PointerStringPair, Symbol,                     </span><br><span class="line">                 PointerStringPairHash, PointerStringPairEqual&gt;</span><br><span class="line">  SymbolsByParentMap;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> FileDescriptor*,</span><br><span class="line">                 hash&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;, streq&gt;</span><br><span class="line">  FilesByNameMap;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;PointerStringPair, <span class="keyword">const</span> FieldDescriptor*,</span><br><span class="line">                 PointerStringPairHash, PointerStringPairEqual&gt;</span><br><span class="line">  FieldsByNameMap;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;DescriptorIntPair, <span class="keyword">const</span> FieldDescriptor*,</span><br><span class="line">                 PointerIntegerPairHash&lt;DescriptorIntPair&gt; &gt;</span><br><span class="line">  FieldsByNumberMap;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;EnumIntPair, <span class="keyword">const</span> EnumValueDescriptor*,</span><br><span class="line">                 PointerIntegerPairHash&lt;EnumIntPair&gt; &gt;</span><br><span class="line">  EnumValuesByNumberMap;</span><br></pre></td></tr></table></figure>
<p><strong>parent的含义</strong></p>
<p>从<code>BUILD_ARRAY</code>的定义和使用，可以理解<code>parent</code>的含义，有如下3种情况：</p>
<ol>
<li>当一个message针对它所包含的成员（<code>field/nested_message/enum/extension</code>）, 这个message的<code>Descriptor*</code> 就是它成员的parent。<pre><code>从函数`DescriptorBuilder::BuildMessage()`中的宏`BUILD_ARRAY`定义可以看出这一点。
</code></pre></li>
<li>一个enum，针对它所包含的<code>enum_value</code>是parent（函数<code>DescriptorBuilder::BuildEnum()</code>中体现）</li>
<li>一个service，针对它所包含的method是parent（函数<code>DescriptorBuilder::BuildService()</code>中体现）</li>
</ol>
<p><strong>具体数据成员</strong></p>
<pre><code>vector&lt;string*&gt; strings_;    // All strings in the pool.
vector&lt;Message*&gt; messages_;  // All messages in the pool.
vector&lt;FileDescriptorTables*&gt; file_tables_;  // All file tables in the pool.
vector&lt;void*&gt; allocations_;  // All other memory allocated in the pool.

SymbolsByNameMap      symbols_by_name_;
FilesByNameMap        files_by_name_;
ExtensionsGroupedByDescriptorMap extensions_;
</code></pre><p><strong>和rollback相关的数据成员</strong></p>
<pre><code>int strings_before_checkpoint_;
int messages_before_checkpoint_;
int file_tables_before_checkpoint_;
int allocations_before_checkpoint_;
vector&lt;const char*      &gt; symbols_after_checkpoint_;
vector&lt;const char*      &gt; files_after_checkpoint_;
vector&lt;DescriptorIntPair&gt; extensions_after_checkpoint_;
</code></pre><p><strong>其它数据成员</strong></p>
<pre><code>vector&lt;string&gt; pending_files_  // stack方式保存的文件名，用来检测文件的循环依赖错误
</code></pre><h3 id="Checkpoint-Rollback"><a href="#Checkpoint-Rollback" class="headerlink" title="Checkpoint/Rollback"></a>Checkpoint/Rollback</h3><p>和数据库事务处理中的概念一样，在确保数据正常时，生成一个检查点(checkpoint)，针对当前状态做一个快照；如果在后续处理过程中，发生问题，做回滚(rollback)，数据恢复到上一个checkpoint，保证基础服务可以继续，提高系统的可用性。</p>
<p>生成checkpoint的点只有2个，都在函数<code>DescriptorBuilder::BuildFile()</code>中：</p>
<ol>
<li>开始修改<code>DescriptorPool::Tables* tables_</code>内容之前；</li>
<li>所有操作都成功之后；</li>
</ol>
<p><code>DescriptorPool::Tables::Checkpoint():</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DescriptorPool::Tables::Checkpoint() &#123;</span><br><span class="line">  <span class="comment">// 记录下当前4个vector的size</span></span><br><span class="line">  strings_before_checkpoint_ = strings_.size();</span><br><span class="line">  messages_before_checkpoint_ = messages_.size();</span><br><span class="line">  file_tables_before_checkpoint_ = file_tables_.size();</span><br><span class="line">  allocations_before_checkpoint_ = allocations_.size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear掉3个`***_after_checkpoint_`的vector</span></span><br><span class="line">  symbols_after_checkpoint_.clear();</span><br><span class="line">  files_after_checkpoint_.clear();</span><br><span class="line">  extensions_after_checkpoint_.clear();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>DescriptorPool::Tables::Rollback():</code></p>
<ol>
<li>从通过name查询的hashmap删除掉<code>after_checkpoint_[]</code>的数据；</li>
<li>清理掉<code>after_checkpoint_[]</code>数据；</li>
<li>通过<code>Checkpoint()</code>记录下来的size，删除vector尾部数据，并且完成resize()，释放掉不再占有的内存空间；</li>
</ol>
<blockquote>
<p>DescriptorPool::Tables中的各个表中的数据是如何注册进来的呢？</p>
</blockquote>
<p>对外接口是<code>DescriptorPool::Tables::AddSymbol()</code>，在<code>DescriptorBuilder</code>类的<code>DescriptorBuilder::AddSymbol()</code>和<code>DescriptorBuilder::AddPackage()</code>被调用。</p>
<h2 id="类DescriptorPool"><a href="#类DescriptorPool" class="headerlink" title="类DescriptorPool"></a>类DescriptorPool</h2><p>负责构造和管理<strong><em>所有的、各种类型的</em></strong>descriptor，并且帮助管理互相<code>cross-linke</code>d的descriptor之间的关系，以及他们之间的数据依赖。可以通过name来从DescriptorPool找到对应descriptor。</p>
<p><strong>按照singleton方式提供服务，全局数据包含：</strong></p>
<pre><code>EncodedDescriptorDatabase* generated_database_ = NULL;
DescriptorPool* generated_pool_ = NULL;
GOOGLE_PROTOBUF_DECLARE_ONCE(generated_pool_init_);
</code></pre><p>使用<code>google::protobuf::GoogleOnceInit</code>（本质是pthread_once）来控制仅仅被init一次。</p>
<p>虽然类DescriptorPool提供了3种构造函数，但从函数<code>InitGeneratedPool()</code>看，仅仅使用了配置<code>DescriptorDatabase*</code>的版本，其余2个并没有使用。在这种情况下，其实 <code>const DescriptorPool* underlay_</code>是为NULL的。</p>
<pre><code>void InitGeneratedPool() {
  generated_database_ = new EncodedDescriptorDatabase;
  generated_pool_ = new DescriptorPool(generated_database_);

  internal::OnShutdown(&amp;DeleteGeneratedPool);
}
</code></pre><p>###<code>DescriptorDatabase* fallback_database_</code>###</p>
<p><strong>作用:</strong></p>
<ol>
<li>用于定制地(on-demand)从某种”大”的database加载产生DescriptorPool。因为database太大，逐个调用<code>DescriptorPool::BuildFile()</code> 来处理原database中的每一个proto文件是低效的。为了提升效率，使用DescriptorPool来封装DescriptorDatabase，并且只建立正真需要的descriptor。</li>
<li>针对编译依赖的每个proto文件，并不是在进程启动时，直接构建出proto中所包含的所有descriptor，而是hang on，直到某个descriptor真的被需要：  <pre><code>(1) 用户调用例如descriptor(), GetDescriptor(), GetReflection()的方法，需要返回descriptor；  
(2) 用户从DescriptorPool::generated_pool()中查找descriptor；  
这也是为什么DescriptorPool的底层数据，需要分层的原因！
</code></pre></li>
</ol>
<p><strong>说明：</strong></p>
<ol>
<li>采用<code>fallback_database_</code>之后，不能调用<code>BuildFile*()</code> 方法来构建pool,只能使用<code>Find*By*()</code> 方法</li>
<li><code>Find*By*()</code> 因为上锁，所以即使没有去访问<code>fallback_database_</code>的请求也会变慢</li>
</ol>
<h3 id="const-DescriptorPool-underlay-的作用"><a href="#const-DescriptorPool-underlay-的作用" class="headerlink" title="const DescriptorPool* underlay_的作用"></a><code>const DescriptorPool* underlay_</code>的作用</h3><p><strong>Underlay的作用（从注释中得到）：</strong>  </p>
<p><mark>仅在内部使用，并且可能存在诡异的问题（many subtle gotchas）</mark>，建议使用DescriptorDatabases来解决问题。</p>
<p><strong>应用场景：</strong>  </p>
<p>需要runtime方式使用DynamicMessage来解析一个.proto文件，已知这个.proto文件的依赖已经按照静态编译方式包含。</p>
<ul>
<li>一方面为了避免重复解析和加载这些依赖内容；</li>
<li>另一方面不能把runtime的.proto添加到原有的generated_pool()产生的DescriptorPool中，所以并不是直接把这个.proto文件的内容添加到全局的、由generated_pool()产生的DescriptorPool中，而是创建一个新的DescriptorPool，将<code>generated_pool()</code>产生的DescriptorPool作为新的pool的underlay。</li>
</ul>
<h3 id="DescriptorPool-Find-By-系列函数"><a href="#DescriptorPool-Find-By-系列函数" class="headerlink" title="DescriptorPool::Find*By*()系列函数"></a><code>DescriptorPool::Find*By*()</code>系列函数</h3><p><strong>作用：</strong></p>
<p>通过name来从DescriptorPool找到对应descriptor时，查找时先上锁（MutexLockMaybe），代码上看是分3个层级数据来查找的：</p>
<ol>
<li>从<code>DescriptorPool::Tables tables_</code>中找，没找到继续第2层中找；</li>
<li>从<code>DescriptorPool* underlay_</code>中找,没找到继续第3层中找；</li>
<li>从<code>DescriptorDatabase* fallback_database_</code>中找对应proto，并且调用临时构造的<code>DescriptorBuilder::Build*()</code>系列接口把生成的descriptor添加到<code>tables_</code>中，然后再从<code>tables_</code>中找；</li>
</ol>
<blockquote>
<p>Q: 这里为什么要临时构造一个DescriptorBuilder来使用呢？<br>答案是：锁是针对第3层<code>DescriptorDatabase* fallback_database_</code>的，因为这个可能被同时读/写</p>
</blockquote>
<h2 id="类DescriptorBuilder"><a href="#类DescriptorBuilder" class="headerlink" title="类DescriptorBuilder"></a>类DescriptorBuilder</h2><p>封装了DescriptorPool，对外提供descriptor的构造。对外最主要的接口是<code>DescriptorBuilder::BuildFile()</code>，通过FileDescriptorProto来构建FileDescriptor。</p>
<h2 id="DescriptorProto系列类"><a href="#DescriptorProto系列类" class="headerlink" title="DescriptorProto系列类"></a>DescriptorProto系列类</h2><p>DescriptorProto系列类，在descriptor.proto文件中定义，用来描述由protobuf产生类型的类型原型（proto）。</p>
<p>一共有如下7种proto</p>
<table>
<thead>
<tr>
<th style="text-align:left">FileDescriptorProto</th>
<th style="text-align:center">用来描述 文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DescriptorProto</td>
<td style="text-align:center">用来描述 消息（message）</td>
</tr>
<tr>
<td style="text-align:left">FieldDescriptorProto</td>
<td style="text-align:center">用来描述 字段</td>
</tr>
<tr>
<td style="text-align:left">EnumDescriptorProto</td>
<td style="text-align:center">用来描述 枚举</td>
</tr>
<tr>
<td style="text-align:left">EnumValueDescriptorProto</td>
<td style="text-align:center">用来描述 枚举值</td>
</tr>
<tr>
<td style="text-align:left">ServiceDescriptorProto</td>
<td style="text-align:center">用来描述 服务器</td>
</tr>
<tr>
<td style="text-align:left">MethodDescriptorProto</td>
<td style="text-align:center">用来描述 服务器方法</td>
</tr>
</tbody>
</table>
<h2 id="类FileDescriptorTables"><a href="#类FileDescriptorTables" class="headerlink" title="类FileDescriptorTables"></a>类FileDescriptorTables</h2><p>单个proto文件中包含的tables，这些tables在文件加载时就固化下来，所以无需使用mutex保护，所以使得依赖单个文件的操作(例如<code>Descriptor::FindFieldByName()</code> )是lock-free的。<br>类<code>FileDescriptorTables</code> 和类 <code>DescriptorPool::Tables</code>过去是在同一个类中定义的。<br>原来Google也有类似的注释：<code>// For historical reasons,xxxxxx。</code></p>
<p>它所包含的数据结构如下：  </p>
<pre><code>SymbolsByParentMap    symbols_by_parent_;
FieldsByNameMap       fields_by_lowercase_name_;
FieldsByNameMap       fields_by_camelcase_name_;
FieldsByNumberMap     fields_by_number_;       // Not including extensions.
EnumValuesByNumberMap enum_values_by_number_;
</code></pre><h2 id="类DescriptorDatabase"><a href="#类DescriptorDatabase" class="headerlink" title="类DescriptorDatabase"></a>类DescriptorDatabase</h2><p>接口类，用于定制地(on-demand)从某种”大”的database加载产生DescriptorPool。因为database太大，逐个调用<code>DescriptorPool::BuildFile()</code> 来处理原database中的每一个proto文件是低效的。<br>为了提升效率，使用DescriptorPool来封装DescriptorDatabase，并且只建立正真需要的descriptor。</p>
<p>包含了4个子类，提供通过name查询file_descriptor_proto 的接口（注意这里是file_descriptor_proto，而不是file_descriptor）。</p>
<h3 id="类SimpleDescriptorDatabase"><a href="#类SimpleDescriptorDatabase" class="headerlink" title="类SimpleDescriptorDatabase"></a>类SimpleDescriptorDatabase</h3><p>索引<code>file_name-&gt; file_descriptor_proto*</code>，拥有被它索引的 <code>file_descriptor_proto*</code>的ownership，并提供<code>add()/find()</code>接口。类SimpleDescriptorDatabase在protobuf中并没有被使用。</p>
<p><strong>内部实现：</strong></p>
<ul>
<li>通过<code>SimpleDescriptorDatabase::DescriptorIndex&lt;const FileDescriptorProto*&gt; index_</code>管理索引结构;</li>
<li>通过<code>vector&lt;const FileDescriptorProto*&gt;  files_to_delete_</code>管理”深拷贝”的部分;</li>
</ul>
<h3 id="类SimpleDescriptorDatabase-DescriptorIndex"><a href="#类SimpleDescriptorDatabase-DescriptorIndex" class="headerlink" title="类SimpleDescriptorDatabase::DescriptorIndex"></a>类SimpleDescriptorDatabase::DescriptorIndex</h3><p><strong>内部实现：</strong></p>
<ol>
<li>由<code>map&lt;string，Value&gt;</code>管理从<code>name-&gt;Value</code>的映射关系；</li>
<li>由<code>map&lt;string，Value&gt;</code>管理file所包含的<code>symbol_name-&gt;Value</code>的映射关系，这里的symbol可以是file包含的message/enum/service；</li>
<li>由<code>map&lt;string，Value&gt;</code>管理file所包含的<code>extension_name-&gt;Value</code>的映射关系；</li>
</ol>
<p><strong>应用：</strong>  </p>
<p>protobuf中仅在如下2个地方被应用： </p>
<ol>
<li>类SimpleDescriptorDatabase中的<code>DescriptorIndex&lt;const FileDescriptorProto*&gt; index_</code></li>
<li>类EncodedDescriptorDatabase中的<code>SimpleDescriptorDatabase::DescriptorIndex&lt;pair&lt;const void*, int&gt; &gt; index_</code></li>
</ol>
<h3 id="类EncodedDescriptorDatabase"><a href="#类EncodedDescriptorDatabase" class="headerlink" title="类EncodedDescriptorDatabase"></a>类EncodedDescriptorDatabase</h3><p><strong>功能说明：</strong></p>
<p>索引<code>file_name-&gt;pair&lt;const void*, int&gt;</code>，结构<code>pair&lt;const void*, int&gt;</code>中的<code>const void*</code>指的是<code>encoded_file_descriptor</code>字符串的地址，<code>int</code>指的是<code>encoded_file_descriptor</code>字符串的长度。被管理的<code>encoded_file_descriptor</code>有两类ownership：  </p>
<ol>
<li>拥有ownership的，通过接口<code>EncodedDescriptorDatabase::AddCopy()</code>实现；</li>
<li>不用有ownership的 ，通过接口<code>EncodedDescriptorDatabase::Add()</code>实现；</li>
</ol>
<p><strong>具体应用：</strong> </p>
<p>每个proto生成的pb.cc中，都包含将本proto文件encoded之后的string添加到EncodedDescriptorDatabase中的函数。例如<code>protobuf/compiler/plugin.pb.cc</code>中的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protobuf_AddDesc_google_2fprotobuf_2fcompiler_2fplugin_2eproto</span><span class="params">()</span> </span>&#123;                                                   </span><br><span class="line"></span><br><span class="line">  …… <span class="comment">//省略函数</span></span><br><span class="line"></span><br><span class="line">  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(</span><br><span class="line">    <span class="string">"\n%google/protobuf/compiler/plugin.proto\022"</span></span><br><span class="line">    <span class="string">"\030google.protobuf.compiler\032 google/protob"</span></span><br><span class="line">    <span class="string">"uf/descriptor.proto\"&#125;\n\024CodeGeneratorRequ"</span></span><br><span class="line">    <span class="string">"est\022\030\n\020file_to_generate\030\001 \003(\t\022\021\n\tparamet"</span></span><br><span class="line">    <span class="string">"er\030\002 \001(\t\0228\n\nproto_file\030\017 \003(\0132$.google.pr"</span></span><br><span class="line">    <span class="string">"otobuf.FileDescriptorProto\"\252\001\n\025CodeGener"</span></span><br><span class="line">    <span class="string">"atorResponse\022\r\n\005error\030\001 \001(\t\022B\n\004file\030\017 \003("</span></span><br><span class="line">    <span class="string">"\01324.google.protobuf.compiler.CodeGenerat"</span></span><br><span class="line">    <span class="string">"orResponse.File\032&gt;\n\004File\022\014\n\004name\030\001 \001(\t\022\027\n"</span></span><br><span class="line">    <span class="string">"\017insertion_point\030\002 \001(\t\022\017\n\007content\030\017 \001(\t"</span>, <span class="number">399</span>);</span><br><span class="line"></span><br><span class="line">  …… <span class="comment">//省略函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>::google::protobuf::DescriptorPool::InternalAddGeneratedFile()</code>定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DescriptorPool::InternalAddGeneratedFile(</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* encoded_file_descriptor, <span class="keyword">int</span> size) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个protobuf产出的.pb.cc文件中都会包含InternalAddGeneratedFile()，在进程启动时会调用这个函数，注册.proto文件对应FileDescriptorProto的raw bytes</span></span><br><span class="line"><span class="comment">// Q：进程启动时会调用这个函数，上一级的入口在哪里呢？每个编译依赖(被include)的proto文件都会注册么？</span></span><br><span class="line"><span class="comment">// 针对编译依赖的每个proto文件，并不是在进程启动时，直接构建出proto中所包含的所有descriptor，而是hang on，直到某个descriptor真的被需要：</span></span><br><span class="line"><span class="comment">// (1) 用户调用例如descriptor(), GetDescriptor(), GetReflection()的方法，需要返回descriptor；</span></span><br><span class="line"><span class="comment">// (2) 用户从DescriptorPool::generated_pool()中查找descriptor；</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 上述2类请求发生时，DescriptorPool先获得并解析FileDescriptorProto，然后根据它产生对应的FileDescriptor（以及它所包含的descriptor）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 因为FileDescriptorProto类型本身也是由protobuf通过protobuf/descriptor.proto文件产生的，所以当解析的时候，需要注意避免使用任何descriptor-based 的操作，避免死锁和死循环。</span></span><br><span class="line"></span><br><span class="line">  InitGeneratedPoolOnce();</span><br><span class="line">  GOOGLE_CHECK(generated_database_-&gt;Add(encoded_file_descriptor, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部实现：</strong></p>
<pre><code>vector&lt;void*&gt; files_to_delete_：记录拥有ownership的encoded_file_descriptor字符串的地址，
</code></pre><h3 id="类DescriptorPoolDatabase"><a href="#类DescriptorPoolDatabase" class="headerlink" title="类DescriptorPoolDatabase"></a>类DescriptorPoolDatabase</h3><p>针对单一DescriptorPool的封装，查询时先调用内置的DescriptorPool接口，从name查找到对应的file_descriptor, 再调用<code>FileDescriptor::CopyTo()</code>,获得<code>file_descriptor_proto</code>.</p>
<h3 id="类MergedDescriptorDatabase"><a href="#类MergedDescriptorDatabase" class="headerlink" title="类MergedDescriptorDatabase"></a>类MergedDescriptorDatabase</h3><p>类DescriptorDatabase的子类，封装多个<code>descriptor_database</code>，本身结构简单，用<code>vector&lt;DescriptorDatabase*&gt;</code>保存，逐个遍历查询。</p>
<h3 id="DescriptorDatabase-相关类的关系图"><a href="#DescriptorDatabase-相关类的关系图" class="headerlink" title="DescriptorDatabase 相关类的关系图"></a>DescriptorDatabase 相关类的关系图</h3><p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_descriptor_database.png" alt="avatar"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/06/protobuf-message/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/protobuf-message/" itemprop="url">Protobuf-Message相关类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-06T22:50:55+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类MessageLite"><a href="#类MessageLite" class="headerlink" title="类MessageLite"></a>类MessageLite</h2><p>所有message的接口类，从名字看是lite的message，普通message也是它的子类。 </p>
<p>MessageLite适合“轻量级”的message（仅仅提供 encoding+序列化 功能，没有使用使用reflection和descriptors）。在确定可以使用“轻量级”的message的场景下，可以在.proto文件中如下增加配置(<code>option optimize_for = LITE_RUNTIME;</code>)，来让protocol compiler产出MessageLite类型的类，这样可以节省runtime资源。</p>
<h2 id="类Message"><a href="#类Message" class="headerlink" title="类Message"></a>类Message</h2><p>接口类，在类MessageLite的基础上增加了descriptors和reflection。</p>
<h2 id="类MessageFactory"><a href="#类MessageFactory" class="headerlink" title="类MessageFactory"></a>类MessageFactory</h2><p>接口类，来创建Message对象，底层是封装了GeneratedMessageFactory类。</p>
<h2 id="类GeneratedMessageFactory"><a href="#类GeneratedMessageFactory" class="headerlink" title="类GeneratedMessageFactory"></a>类GeneratedMessageFactory</h2><p>MessageFactory的子类，singleton模式。 </p>
<p>singleton模式是通过全局变量<code>GeneratedMessageFactory* generated_message_factory_</code>结合<code>GOOGLE_PROTOBUF_DECLARE_ONCE</code>（本质是<code>pthread_once</code>）来实现。</p>
<h3 id="内部核心数据结构："><a href="#内部核心数据结构：" class="headerlink" title="内部核心数据结构："></a>内部核心数据结构：</h3><ol>
<li><code>hash_map&lt;const char*, RegistrationFunc*&gt;</code>： 成员变量<code>file_map_</code>，从文件名到注册函数的映射关系，这个关系是在static初始化阶段完成，所以不需要锁；</li>
<li><code>hash_map&lt;const Descriptor*, const Message*&gt;</code>：成员变量<code>type_map_</code>，<code>Descriptor*</code>到对应 <code>Message*</code>（这里其实是Message的prototype，调用它的New()接口，才创建具体的Message对象）的映射关系，这个关系会涉及多线程处理，使用读写锁保护；</li>
</ol>
<h3 id="对外关键接口："><a href="#对外关键接口：" class="headerlink" title="对外关键接口："></a>对外关键接口：</h3><blockquote>
<p>const Message<em> GeneratedMessageFactory::GetPrototype(const Descriptor</em> type) </p>
</blockquote>
<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><p>从descriptor找到对应message的prototype</p>
<h4 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h4><ol>
<li>上读锁，从<code>hash_map&lt;const Descriptor*, const Message*&gt;</code>找，有则返回、无则继续；</li>
<li>校验descriptor对应proto文件是否由全局的DescriptorPool管理；</li>
<li>用descriptor对应文件名从<code>hash_map&lt;const char*, RegistrationFunc*&gt;</code>找注册函数<code>registration_func</code>，无则返回、有则继续；</li>
<li>上写锁，判断是否有其它线程已经抢占（preempt）写入<code>hash_map&lt;const Descriptor*, const Message*&gt;</code>。如果没有，调用registration_func完成注册。并且从<code>hash_map&lt;const Descriptor*, const Message*&gt;</code>找到对应Message的prototype</li>
</ol>
<blockquote>
<p>void RegisterFile(const char<em> file, RegistrationFunc</em> registration_func)</p>
</blockquote>
<h4 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h4><p>注册<code>file_name</code>和对应的注册函数到<code>hash_map&lt;const char*, RegistrationFunc*&gt;</code></p>
<blockquote>
<p>void RegisterType(const Descriptor<em> descriptor, const Message</em> prototype)</p>
</blockquote>
<h4 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h4><p>注册descriptor和message的关系到<code>hash_map&lt;const Descriptor*, const Message*&gt;</code></p>
<h4 id="注册关系的生成："><a href="#注册关系的生成：" class="headerlink" title="注册关系的生成："></a>注册关系的生成：</h4><p>在每个.pb.cc都会调用，例如<code>protobuf/compiler/plugin.pb.cc</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">protobuf_AddDesc_google_2fprotobuf_2fcompiler_2fplugin_2eproto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	…… <span class="comment">// 省略</span></span><br><span class="line">	  </span><br><span class="line">	  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(</span><br><span class="line">	    <span class="string">"google/protobuf/compiler/plugin.proto"</span>, &amp;protobuf_RegisterTypes);                                                                                                      </span><br><span class="line">	</span><br><span class="line">	…… <span class="comment">// 省略</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册函数定义也在protobuf/compiler/plugin.pb.cc 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protobuf_RegisterTypes</span><span class="params">(<span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span> </span>&#123;</span><br><span class="line">  protobuf_AssignDescriptorsOnce();</span><br><span class="line">  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(</span><br><span class="line">    CodeGeneratorRequest_descriptor_, &amp;CodeGeneratorRequest::default_instance());</span><br><span class="line">  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(</span><br><span class="line">    CodeGeneratorResponse_descriptor_, &amp;CodeGeneratorResponse::default_instance());</span><br><span class="line">  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(</span><br><span class="line">    CodeGeneratorResponse_File_descriptor_, &amp;CodeGeneratorResponse_File::default_instance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对plugin.proto中的每一个Message，都会有对应的descriptor和default message对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeGeneratorRequest_descriptor_和CodeGeneratorRequest::default_instance()</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span> MessageFactory::InternalRegisterGeneratedMessage(</span><br><span class="line">	    <span class="keyword">const</span> Descriptor* descriptor, <span class="keyword">const</span> Message* prototype) &#123;</span><br><span class="line">	  GeneratedMessageFactory::singleton()-&gt;RegisterType(descriptor, prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终是调用了 <code>GeneratedMessageFactory::RegisterType()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">void</span> GeneratedMessageFactory::RegisterType(<span class="keyword">const</span> Descriptor* descriptor,</span><br><span class="line">	                                           <span class="keyword">const</span> Message* prototype) &#123;</span><br><span class="line">	…  <span class="comment">// 省略</span></span><br><span class="line">	  <span class="keyword">if</span> (!InsertIfNotPresent(&amp;type_map_, descriptor, prototype)) &#123;</span><br><span class="line">	…  <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类DynamicMessageFactory"><a href="#类DynamicMessageFactory" class="headerlink" title="类DynamicMessageFactory"></a>类DynamicMessageFactory</h2><p>MessageFactory的子类，用于处理非compile-time的message。</p>
<h2 id="相关类的关系图"><a href="#相关类的关系图" class="headerlink" title="相关类的关系图"></a>相关类的关系图</h2><p><img src="https://github.com/felix1xuwei/MarkdownPics/raw/master/pics/protobuf/pb_message_class.png" alt="avatar"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/03/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Felix1XuWei's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/hello-world/" itemprop="url">hello-world</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-03T22:47:50+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Hello World!</strong>  </p>
<p>收到 海玉 和 有成 的启发，今天也开一个自己的blog。 </p>
<p>过去读过的源码，主要以厂内的一些基础库为主(记录在厂内wiki上)，后续会稍微调整方向到开源类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Xu Wei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xu Wei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
